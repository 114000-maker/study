<!---
ğŸ‘‡One Click Stickerå½±ç‰‡ä»‹ç´¹ğŸ‘‡https://youtu.be/JJGgQ7tKb0U
-->

import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { motion } from 'framer-motion';

// --- è¼”åŠ©å‡½å¼ ---

// å°‡æª”æ¡ˆè½‰æ›ç‚º Base64
const toBase64 = file => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = error => reject(error);
});

// å¸¶æœ‰é‡è©¦æ©Ÿåˆ¶çš„ fetch å‡½å¼
const fetchWithRetry = (url, options, retries = 5, backoff = 1000) => {
    return new Promise((resolve, reject) => {
        const attempt = async (retryCount, delay) => {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API éŒ¯èª¤:', errorData);
                    if (response.status === 429 && retryCount > 0) {
                        console.log(`è«‹æ±‚é »ç‡éé«˜ã€‚å°‡åœ¨ ${delay / 1000} ç§’å¾Œé‡è©¦...`);
                        setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                    } else if (response.status === 401) {
                        reject(new Error(`API è«‹æ±‚å¤±æ•—ï¼Œç‹€æ…‹ç¢¼ 401ï¼šæœªæˆæ¬Šã€‚è«‹ç¢ºèªæ‚¨çš„ API é‡‘é‘°æ˜¯å¦æœ‰æ•ˆã€‚`));
                    }
                    else {
                        reject(new Error(`API è«‹æ±‚å¤±æ•—ï¼Œç‹€æ…‹ç¢¼ ${response.status}: ${errorData.error?.message || 'æœªçŸ¥éŒ¯èª¤'}`));
                    }
                } else {
                    resolve(response.json());
                }
            } catch (error) {
                if (retryCount > 0) {
                    console.log(`è«‹æ±‚å¤±æ•—ã€‚å°‡åœ¨ ${delay / 1000} ç§’å¾Œé‡è©¦...`, error);
                    setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                } else {
                    reject(error);
                }
            }
        };
        attempt(retries, backoff);
    });
};

// å¸¶æœ‰é‡è©¦æ©Ÿåˆ¶çš„åœ–ç‰‡ç”Ÿæˆå‡½å¼
const generateImageWithRetry = async (payload, totalAttempts = 3) => {
    let lastError;
    for (let attempt = 1; attempt <= totalAttempts; attempt++) {
        try {
            const apiKey = ""; // Canvas ç’°å¢ƒæœƒè‡ªå‹•è™•ç†ç©ºçš„é‡‘é‘°

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
            
            const result = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

            if (base64Data) {
                return `data:image/png;base64,${base64Data}`;
            }

            lastError = new Error("API æœªè¿”å›åœ–ç‰‡è³‡æ–™ã€‚");
            console.warn(`ç¬¬ ${attempt}/${totalAttempts} æ¬¡å˜—è©¦: ${lastError.message}`);

        } catch (error) {
            lastError = error;
            console.error(`ç¬¬ ${attempt}/${totalAttempts} æ¬¡å˜—è©¦å¤±æ•—:`, error);
        }

        if (attempt < totalAttempts) {
            const delay = 2500 * Math.pow(2, attempt - 1);
            console.log(`ç­‰å¾… ${delay / 1000} ç§’å¾Œé€²è¡Œä¸‹ä¸€æ¬¡å˜—è©¦...`);
            await new Promise(res => setTimeout(res, delay));
        }
    }

    throw new Error(`åœ–ç‰‡ç”Ÿæˆåœ¨ ${totalAttempts} æ¬¡å˜—è©¦å¾Œå¤±æ•—ã€‚æœ€å¾ŒéŒ¯èª¤: ${lastError?.message || 'æœªçŸ¥éŒ¯èª¤'}`);
};

// æ”¹é€²çš„å»èƒŒåŠŸèƒ½ - ä½¿ç”¨å¤šç¨®æ–¹æ³•ç¢ºä¿èƒŒæ™¯å»é™¤
const removeBackground = (imageUrl) => {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.width;
            canvas.height = img.height;
            
            // ç¹ªè£½åŸå§‹åœ–ç‰‡
            ctx.drawImage(img, 0, 0);
            
            // ç²å–åœ–ç‰‡æ•¸æ“š
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // èª¿è©¦ï¼šæ”¶é›†ä¸€äº›é¡è‰²æ¨£æœ¬
            const colorSamples = [];
            let sampleCount = 0;
            
            // èƒŒæ™¯å»é™¤ç®—æ³• - æª¢æ¸¬äº®ç¶ è‰²èƒŒæ™¯ä¸¦è¨­ç‚ºé€æ˜
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // æ”¶é›†ä¸€äº›é¡è‰²æ¨£æœ¬ç”¨æ–¼èª¿è©¦
                if (sampleCount < 10 && Math.random() < 0.001) {
                    colorSamples.push({ r, g, b, a });
                    sampleCount++;
                }
                
                // ä½¿ç”¨ HSV è‰²å½©ç©ºé–“æª¢æ¸¬ç¶ è‰²èƒŒæ™¯
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;
                
                // è¨ˆç®—è‰²ç›¸ (Hue)
                let hue = 0;
                if (delta !== 0) {
                    if (max === g) {
                        hue = 60 * ((b - r) / delta + 2);
                    } else if (max === r) {
                        hue = 60 * ((g - b) / delta + 4);
                    } else {
                        hue = 60 * ((r - g) / delta);
                    }
                }
                if (hue < 0) hue += 360;
                
                // è¨ˆç®—é£½å’Œåº¦å’Œæ˜åº¦
                const saturation = max === 0 ? 0 : delta / max;
                const value = max / 255;
                
                // æª¢æ¸¬ç¶ è‰²èƒŒæ™¯çš„å¤šç¨®æ¢ä»¶
                const isGreenHue = (hue >= 60 && hue <= 180); // ç¶ è‰²è‰²ç›¸ç¯„åœ
                const isHighSaturation = saturation > 0.3;    // é«˜é£½å’Œåº¦
                const isBright = value > 0.4;                 // è¶³å¤ æ˜äº®
                const isGreenDominant = (g > r + 30 && g > b + 30); // ç¶ è‰²ä¸»å°
                
                // æª¢æ¸¬é‚Šç·£åƒç´ 
                const pixelIndex = i / 4;
                const x = pixelIndex % canvas.width;
                const y = Math.floor(pixelIndex / canvas.width);
                const isEdgePixel = (
                    x < 15 || x > canvas.width - 15 || 
                    y < 15 || y > canvas.height - 15
                );
                
                // ç¶œåˆåˆ¤æ–·æ˜¯å¦ç‚ºèƒŒæ™¯
                const isBackground = (
                    // æ¢ä»¶1ï¼šç¶ è‰²è‰²ç›¸ + é«˜é£½å’Œåº¦ + è¶³å¤ æ˜äº®
                    (isGreenHue && isHighSaturation && isBright) ||
                    // æ¢ä»¶2ï¼šé‚Šç·£å€åŸŸçš„ç¶ è‰²ä¸»å°åƒç´ 
                    (isEdgePixel && isGreenDominant && g > 100) ||
                    // æ¢ä»¶3ï¼šéå¸¸äº®çš„ç¶ è‰²
                    (g > 200 && r < 50 && b < 50) ||
                    // æ¢ä»¶4ï¼šç´”ç¶ è‰²æˆ–æ¥è¿‘ç´”ç¶ è‰²
                    (Math.abs(r - 0) < 20 && Math.abs(g - 255) < 20 && Math.abs(b - 0) < 20)
                );
                
                if (isBackground) {
                    data[i + 3] = 0; // è¨­ alpha ç‚º 0ï¼ˆé€æ˜ï¼‰
                }
            }
            
            // èª¿è©¦è¼¸å‡º
            console.log('å»èƒŒè™•ç† - é¡è‰²æ¨£æœ¬:', colorSamples);
            
            // æª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ çš„é€æ˜åƒç´ è¢«å‰µå»º
            let transparentPixels = 0;
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] === 0) transparentPixels++;
            }
            const transparencyRatio = transparentPixels / (data.length / 4);
            console.log(`å»èƒŒçµæœ: ${Math.round(transparencyRatio * 100)}% çš„åƒç´ è¢«è¨­ç‚ºé€æ˜`);
            
            // å¦‚æœé€æ˜åƒç´ å¤ªå°‘ï¼Œå˜—è©¦å‚™ç”¨æ–¹æ³•
            if (transparencyRatio < 0.1) {
                console.log('äº®ç¶ è‰²æª¢æ¸¬æ•ˆæœä¸ä½³ï¼Œå˜—è©¦å‚™ç”¨å»èƒŒæ–¹æ³•...');
                
                // å‚™ç”¨æ–¹æ³•ï¼šæª¢æ¸¬é‚Šç·£å€åŸŸçš„ä¸»è¦é¡è‰²
                const edgeColors = [];
                const edgeSize = 5;
                
                // æ”¶é›†é‚Šç·£é¡è‰²
                for (let y = 0; y < edgeSize; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        edgeColors.push({
                            r: data[idx],
                            g: data[idx + 1],
                            b: data[idx + 2]
                        });
                    }
                }
                
                // æ‰¾åˆ°æœ€å¸¸è¦‹çš„é‚Šç·£é¡è‰²
                const colorCounts = {};
                edgeColors.forEach(color => {
                    const key = `${Math.floor(color.r/20)*20},${Math.floor(color.g/20)*20},${Math.floor(color.b/20)*20}`;
                    colorCounts[key] = (colorCounts[key] || 0) + 1;
                });
                
                const mostCommonColor = Object.keys(colorCounts).reduce((a, b) => 
                    colorCounts[a] > colorCounts[b] ? a : b
                );
                const [targetR, targetG, targetB] = mostCommonColor.split(',').map(Number);
                
                console.log('æª¢æ¸¬åˆ°çš„ä¸»è¦èƒŒæ™¯é¡è‰²:', { r: targetR, g: targetG, b: targetB });
                
                // ä½¿ç”¨æª¢æ¸¬åˆ°çš„ä¸»è¦é¡è‰²é€²è¡Œå»èƒŒ
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    const colorDistance = Math.sqrt(
                        Math.pow(r - targetR, 2) + 
                        Math.pow(g - targetG, 2) + 
                        Math.pow(b - targetB, 2)
                    );
                    
                    // å¦‚æœé¡è‰²æ¥è¿‘ä¸»è¦èƒŒæ™¯é¡è‰²ï¼Œè¨­ç‚ºé€æ˜
                    if (colorDistance < 50) {
                        data[i + 3] = 0;
                    }
                }
            }
            
            // å°‡è™•ç†å¾Œçš„æ•¸æ“šæ”¾å› canvas
            ctx.putImageData(imageData, 0, 0);
            
            // è½‰æ›ç‚º base64
            const processedImageUrl = canvas.toDataURL('image/png');
            resolve(processedImageUrl);
        };
        
        img.onerror = () => {
            reject(new Error('åœ–ç‰‡è¼‰å…¥å¤±æ•—'));
        };
        
        img.src = imageUrl;
    });
};


/**
 * åœ–ç‰‡ç”ŸæˆæŒ‡ä»¤
 */
const getModelInstruction = (prompt, addText) => {
    let instruction = `The highest priority is to maintain the exact facial features, likeness, and perceived gender of the person in the provided reference photo.
Transform the person into a cute, expressive 1:1 aspect ratio chat sticker based on the following action: "${prompt.base}".
The sticker MUST have a thick, clean white outline and a subtle drop shadow to make it pop.
The sticker MUST have a solid, bright lime green background (RGB: 0, 255, 0) - this is crucial for background removal later.
The final image should be a high-quality PNG.
Do not alter the person's core facial structure.`;

    if (addText && prompt.memeText) {
        instruction += `\nAdditionally, incorporate the text "${prompt.memeText}" into the sticker design in a fun, stylized, and readable English font that matches the emotion. The text should be easily visible against the bright lime green background.`;
    }

    return instruction;
};

// --- åœ–ç¤º ---

const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-10 h-10"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /></svg>;
const IconSparkles = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" /></svg>;
const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>;
const IconCamera = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 0 0-1.134-.175 2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.776 48.776 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.039l-.821 1.316Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0ZM18.75 10.5h.008v.008h-.008V10.5Z" /></svg>;
const IconZip = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" /></svg>;


// --- React å…ƒä»¶ (é‡æ–°è¨­è¨ˆèˆ‡ç°¡åŒ–) ---

const Button = ({ children, onClick, disabled, primary = false, className = '' }) => {
    const baseClass = "px-6 py-2 rounded-md font-semibold tracking-wider uppercase transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed";
    const themeClass = primary 
        ? "bg-yellow-400 text-black hover:bg-yellow-300" 
        : "bg-transparent border border-gray-600 text-gray-300 hover:bg-gray-800 hover:text-white";
    
    return (
        <button
            onClick={onClick}
            disabled={disabled}
            className={`${baseClass} ${themeClass} ${className}`}
        >
            {children}
        </button>
    );
};

// å°ˆç‚ºè²¼åœ–è¨­è¨ˆçš„ç°¡åŒ–é¡¯ç¤ºå¡
const StickerDisplay = ({ emotion, imageUrl, onDownload, onRegenerate, isDynamic, isProcessed = false }) => {
    return (
        <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
            whileHover={isDynamic ? { y: -8, rotate: Math.random() * 6 - 3 } : {}}
            className="relative group p-4 bg-gray-900/50 rounded-xl shadow-lg transition-all duration-300 hover:shadow-2xl border border-gray-800"
        >
            <div className="aspect-square bg-grid-pattern flex items-center justify-center rounded-lg relative">
                <img src={imageUrl} alt={`è²¼åœ–è¡¨æƒ… ${emotion}`} className="w-full h-full object-contain" />
                {/* å»èƒŒç‹€æ…‹æŒ‡ç¤ºå™¨ */}
                {isProcessed && (
                    <div className="absolute top-2 left-2 bg-green-500 text-white text-xs px-2 py-1 rounded-full font-semibold">
                        é€æ˜èƒŒæ™¯
                    </div>
                )}
            </div>
            <p className="text-center mt-3 text-lg font-semibold text-gray-300 px-3">{emotion}</p>
            
            <div className="absolute top-3 right-3 z-10 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
                <button
                    onClick={onRegenerate}
                    className="p-2 rounded-full bg-black/60 text-white hover:bg-black/80 transition-colors backdrop-blur-sm shadow-lg"
                    aria-label="é‡æ–°ç”Ÿæˆè²¼åœ–"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M16.023 16.023A7.5 7.5 0 1 0 8.25 8.25V6.75a.75.75 0 0 1 1.5 0v3.75a.75.75 0 0 1-.75.75H5.25a.75.75 0 0 1 0-1.5h2.37a5.98 5.98 0 0 1 8.403 8.403Z" /></svg>
                </button>
                <button
                    onClick={() => onDownload(imageUrl, emotion)}
                    className="p-2 rounded-full bg-black/60 text-white hover:bg-black/80 transition-colors backdrop-blur-sm shadow-lg"
                    aria-label="ä¸‹è¼‰è²¼åœ–"
                >
                    <IconDownload />
                </button>
            </div>
        </motion.div>
    );
};

const SkeletonLoader = ({ className }) => (
    <div className={`animate-pulse bg-gray-800 ${className}`}></div>
);

// å°ˆç‚ºè²¼åœ–è¨­è¨ˆçš„ç°¡åŒ–è¼‰å…¥å¡
const LoadingCard = ({ emotion }) => {
    return (
        <div className="p-4 bg-gray-900 rounded-xl shadow-md">
            <div className="aspect-square bg-grid-pattern rounded-lg relative flex items-center justify-center">
                 <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-yellow-400"></div>
            </div>
            <div className="mt-3 flex justify-center">
                <SkeletonLoader className="h-5 w-1/2 rounded-md" />
            </div>
        </div>
    );
};

// å°ˆç‚ºè²¼åœ–è¨­è¨ˆçš„ç°¡åŒ–éŒ¯èª¤å¡
const ErrorCard = ({ emotion, onRegenerate }) => {
    return (
        <div className="p-4 bg-gray-900 rounded-xl shadow-md border border-red-500/30">
            <div className="aspect-square bg-grid-pattern rounded-lg flex flex-col items-center justify-center text-center p-4 border-2 border-dashed border-red-500/50">
                 <p className="text-red-400 font-medium mb-4">ç”Ÿæˆå¤±æ•—</p>
                 {onRegenerate && (
                     <Button onClick={onRegenerate} primary>
                         é‡è©¦
                     </Button>
                 )}
            </div>
            <p className="text-center mt-3 text-lg font-semibold text-gray-300 px-3">{emotion}</p>
        </div>
    );
};


// è¨»ï¼šErrorNotification å’Œ CameraModal å…ƒä»¶å› ç‚ºæ˜¯ç¨ç«‹çš„ï¼Œæ‰€ä»¥ä¿æŒä¸è®Šã€‚
const ErrorNotification = ({ message, onDismiss }) => {
    if (!message) return null;
    return (
        <div className="fixed top-5 left-1/2 z-50 w-full max-w-md p-4 bg-gray-900 border border-gray-700 text-gray-300 rounded-lg shadow-2xl flex items-center justify-between animate-fade-in-down" style={{ transform: 'translateX(-50%)' }}>
            <span>{message}</span>
            <button onClick={onDismiss} className="p-1 rounded-full hover:bg-gray-800 transition-colors ml-4">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-500"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>
    );
};

const CameraModal = ({ isOpen, onClose, onCapture }) => {
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const streamRef = useRef(null);
    const [capturedImage, setCapturedImage] = useState(null);
    const [cameraError, setCameraError] = useState(null);

    const stopCamera = useCallback(() => {
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
        }
        if (videoRef.current) {
            videoRef.current.srcObject = null;
        }
    }, []);

    const startCamera = useCallback(async () => {
        if (videoRef.current) {
            setCameraError(null);
            try {
                stopCamera();
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1024 }, height: { ideal: 1024 }, facingMode: 'user' }
                });
                videoRef.current.srcObject = stream;
                streamRef.current = stream;
            } catch (err) {
                console.error("å­˜å–ç›¸æ©Ÿæ™‚ç™¼ç”ŸéŒ¯èª¤:", err);
                setCameraError("ç›¸æ©Ÿå­˜å–è¢«æ‹’çµ•ã€‚è«‹åœ¨æ‚¨çš„ç€è¦½å™¨è¨­å®šä¸­å…è¨±ç›¸æ©Ÿå­˜å–ã€‚");
            }
        }
    }, [stopCamera]);

    useEffect(() => {
        if (isOpen && !capturedImage) {
            startCamera();
        } else {
            stopCamera();
        }
        return () => {
            stopCamera();
        };
    }, [isOpen, capturedImage, startCamera, stopCamera]);


    const handleCapture = () => {
        if (videoRef.current && canvasRef.current) {
            const video = videoRef.current;
            const canvas = canvasRef.current;
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const context = canvas.getContext('2d');
            context.scale(-1, 1);
            context.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/png');
            setCapturedImage(dataUrl);
        }
    };

    const handleConfirm = () => {
        if (capturedImage) {
            onCapture(capturedImage);
            onClose();
        }
    };

    const handleRetake = () => {
        setCapturedImage(null);
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
             <motion.div 
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{ duration: 0.2 }}
                className="bg-gray-900 rounded-2xl p-6 border border-gray-700 shadow-2xl w-full max-w-2xl text-center relative"
             >
                <h3 className="text-2xl font-semibold mb-4 text-white">ç›¸æ©Ÿ</h3>
                <div className="aspect-square bg-black rounded-lg overflow-hidden relative mb-4 flex items-center justify-center">
                    {cameraError ? (
                        <div className="p-4 text-red-400">{cameraError}</div>
                    ) : (
                        <>
                            {capturedImage ? (
                                <img src={capturedImage} alt="æ‹æ”é è¦½" className="w-full h-full object-cover" />
                            ) : (
                                <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover transform -scale-x-100"></video>
                            )}
                        </>
                    )}
                </div>

                <div className="flex justify-center gap-4">
                    {capturedImage ? (
                        <>
                            <Button onClick={handleRetake}>é‡æ‹</Button>
                            <Button onClick={handleConfirm} primary>ä½¿ç”¨ç…§ç‰‡</Button>
                        </>
                    ) : (
                       <button onClick={handleCapture} disabled={!!cameraError} className="w-20 h-20 rounded-full bg-white border-4 border-gray-600 focus:outline-none focus:ring-4 focus:ring-yellow-400 transition-all hover:border-yellow-400 disabled:opacity-50 disabled:cursor-not-allowed"></button>
                    )}
                </div>
                
                <button onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full bg-gray-800/70 text-white hover:bg-gray-700 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>
                </button>
                <canvas ref={canvasRef} className="hidden"></canvas>
            </motion.div>
        </div>
    );
};

const App = () => {
    // æ ¸å¿ƒç‹€æ…‹
    const [uploadedImage, setUploadedImage] = useState(null);
    const [generatedImages, setGeneratedImages] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const fileInputRef = useRef(null);
    const [isUploading, setIsUploading] = useState(false);
    const [isCameraOpen, setIsCameraOpen] = useState(false);
    const resultsRef = useRef(null);
    
    // å»èƒŒåŠŸèƒ½ç‹€æ…‹
    const [isRemovingBackground, setIsRemovingBackground] = useState(false);
    const [removeBgProgress, setRemoveBgProgress] = useState(0);
    const [processedImages, setProcessedImages] = useState([]);
    
    // è²¼åœ–é¸æ“‡èˆ‡é¸é …ç‹€æ…‹
    const [selectedStickers, setSelectedStickers] = useState([]);
    const [addText, setAddText] = useState(true);
    const [isDynamic, setIsDynamic] = useState(true);
    const [isZipping, setIsZipping] = useState(false);
    
    // Gemini åŠŸèƒ½ç‹€æ…‹
    const [customIdeaInput, setCustomIdeaInput] = useState('');
    const [customStickerPack, setCustomStickerPack] = useState([]);
    const [isGeneratingIdeas, setIsGeneratingIdeas] = useState(false);
    const [suggestedThemes, setSuggestedThemes] = useState([]);
    const [isSuggestingThemes, setIsSuggestingThemes] = useState(false);


    // é è¨­è²¼åœ–åŒ…å®šç¾©
    const defaultStickerPack = useMemo(() => ({
        name: 'AI è²¼åœ–åŒ…',
        description: 'å¾æ‚¨çš„ç…§ç‰‡ç”Ÿæˆæœ‰è¶£çš„èŠå¤©è²¼åœ–ã€‚',
        icon: 'ğŸ˜œ',
        prompts: [
            { id: 'é–‹å¿ƒ', base: 'a happy, joyful, smiling expression, maybe with stars in the eyes', memeText: 'YAY!' },
            { id: 'å‚·å¿ƒ', base: 'a sad expression, with cartoonishly large tears streaming down the face', memeText: 'SO SAD' },
            { id: 'å¤§ç¬‘', base: 'laughing out loud hysterically, eyes squeezed shut', memeText: 'LOL' },
            { id: 'ç”Ÿæ°£', base: 'an angry, fuming expression with red cheeks and steam coming out of the ears', memeText: 'GRRR' },
            { id: 'æ„›å¿ƒ', base: 'an adoring expression with large heart-shaped eyes', memeText: 'UWU' },
            { id: 'OK', base: 'giving a cheerful thumbs-up sign', memeText: 'OK!' },
            { id: 'å•è™Ÿ', base: 'a confused expression with question marks floating around the head', memeText: '???' },
            { id: 'æƒ³ç¡', base: 'a very sleepy, yawning expression with a snot bubble', memeText: 'Zzz...' },
            { id: 'é©šè¨', base: 'a shocked, surprised expression with wide eyes and open mouth, like "wow"', memeText: 'WOW!' },
            { id: 'æ€è€ƒ', base: 'a thoughtful expression with a finger on the chin, looking upwards', memeText: 'Hmm...' },
            { id: 'é›£é', base: 'a crying expression with a quivering lip, feeling wronged', memeText: 'SNIFF...' },
            { id: 'æ‹œè¨—', base: 'a pleading expression with big, shimmering "puppy dog" eyes', memeText: 'Pls?' },
        ]
    }), []);
    
    const activeStickerPack = customStickerPack.length > 0 ? customStickerPack : defaultStickerPack.prompts;

    // å…ƒä»¶æ›è¼‰æ™‚è‡ªå‹•é¸æ“‡æ‰€æœ‰è²¼åœ–ä¸¦è¼‰å…¥ JSZip
    useEffect(() => {
        setSelectedStickers(defaultStickerPack.prompts.map(p => p.id));
        
        const script = document.createElement('script');
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.async = true;
        document.body.appendChild(script);

        return () => {
            document.body.removeChild(script);
        };
    }, [defaultStickerPack]);


    const handleStickerSelection = (stickerId) => {
        setSelectedStickers(prev => 
            prev.includes(stickerId)
                ? prev.filter(id => id !== stickerId)
                : [...prev, stickerId]
        );
    };

    const regenerateImageAtIndex = async (imageIndex) => {
        const imageToRegenerate = generatedImages[imageIndex];
        if (!imageToRegenerate) return;
    
        setGeneratedImages(prev => prev.map((img, index) =>
            index === imageIndex ? { ...img, status: 'pending' } : img
        ));
        setError(null);
    
        const originalPrompts = activeStickerPack.filter(p => generatedImages.map(gi => gi.id).includes(p.id));
        const prompt = originalPrompts[imageIndex];

        if (!prompt) {
            setError("æ‰¾ä¸åˆ°è¦é‡æ–°ç”Ÿæˆçš„æç¤ºã€‚");
            setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'failed' } : img));
            return;
        }
    
        try {
            const imageWithoutPrefix = uploadedImage.split(',')[1];
            const modelInstruction = getModelInstruction(prompt, addText);
            
            const payload = {
                contents: [{
                    parts: [
                        { text: modelInstruction },
                        { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }
                    ]
                }],
            };
    
            const imageUrl = await generateImageWithRetry(payload);
    
            setGeneratedImages(prev => prev.map((img, index) =>
                index === imageIndex ? { ...img, status: 'success', imageUrl } : img
            ));
    
        } catch (err) {
            console.error(`ç‚º ${prompt.id} é‡æ–°ç”Ÿæˆå¤±æ•—:`, err);
            setError(`å“å‘€ï¼ç‚º "${prompt.id}" é‡æ–°ç”Ÿæˆå¤±æ•—ã€‚è«‹å†è©¦ä¸€æ¬¡ã€‚`);
            setGeneratedImages(prev => prev.map((img, index) =>
                index === imageIndex ? { ...img, status: 'failed' } : img
            ));
        }
    };
    
    const handleImageUpload = async (event) => {
        const file = event.target.files[0];
        if (file) {
            setIsUploading(true);
            setError(null);
            try {
                const base64Image = await toBase64(file);
                setUploadedImage(base64Image);
                setGeneratedImages([]); 
                setSuggestedThemes([]); // æ¸…é™¤èˆŠçš„å»ºè­°
            } catch (err) {
                console.error("åœ–ç‰‡ä¸Šå‚³æ™‚ç™¼ç”ŸéŒ¯èª¤:", err);
                setError("è©²åœ–ç‰‡ç„¡æ³•è™•ç†ã€‚è«‹å˜—è©¦å…¶ä»–æª”æ¡ˆã€‚");
            } finally {
                setIsUploading(false);
            }
        }
    };
    
    const handleCaptureConfirm = (imageDataUrl) => {
        setUploadedImage(imageDataUrl);
        setGeneratedImages([]);
        setError(null);
        setSuggestedThemes([]); // æ¸…é™¤èˆŠçš„å»ºè­°
    };

    const handleGenerateClick = async () => {
        if (!uploadedImage) {
            setError("è«‹å…ˆä¸Šå‚³ä¸€å¼µç…§ç‰‡ï¼");
            return;
        }

        if (selectedStickers.length === 0) {
            setError("è«‹è‡³å°‘é¸æ“‡ä¸€å€‹è²¼åœ–ä¾†ç”Ÿæˆï¼");
            return;
        }

        setIsLoading(true);
        setError(null);
        setGeneratedImages([]);
        
        setTimeout(() => {
            resultsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);

        const imageWithoutPrefix = uploadedImage.split(',')[1];
        const promptsForGeneration = activeStickerPack.filter(p => selectedStickers.includes(p.id));

        const initialPlaceholders = promptsForGeneration.map(p => ({
            id: p.id,
            memeText: p.memeText,
            status: 'pending',
            imageUrl: null,
        }));
        setGeneratedImages(initialPlaceholders);

        for (let i = 0; i < promptsForGeneration.length; i++) {
            const p = promptsForGeneration[i];
            try {
                const modelInstruction = getModelInstruction(p, addText);
                
                const payload = {
                    contents: [{
                        parts: [
                            { text: modelInstruction },
                            { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }
                        ]
                    }],
                };

                const imageUrl = await generateImageWithRetry(payload);

                setGeneratedImages(prev => prev.map((img, index) => 
                    index === i ? { ...img, status: 'success', imageUrl } : img
                ));

            } catch (err) {
                console.error(`ç‚º ${p.id} ç”Ÿæˆåœ–ç‰‡åœ¨æ‰€æœ‰é‡è©¦å¾Œå¤±æ•—:`, err);
                setGeneratedImages(prev => prev.map((img, index) =>
                    index === i ? { ...img, status: 'failed' } : img
                ));
            }
        }

        setIsLoading(false);
    };

    const triggerDownload = (href, fileName) => {
        const link = document.createElement('a');
        link.href = href;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
    
    const handleDownloadRequest = (imageUrl, emotion, isProcessed = false) => {
        const suffix = isProcessed ? '-transparent' : '';
        const fileName = `sticker-${emotion.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`;
        triggerDownload(imageUrl, fileName);
    };

    const handleDownloadAllAsZip = async () => {
        if (isZipping || typeof window.JSZip === 'undefined') {
            if (typeof window.JSZip === 'undefined') {
                 setError("å£“ç¸®ç¨‹å¼åº«å°šæœªè¼‰å…¥ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
            }
            return;
        }
        
        setIsZipping(true);
        setError(null);
        
        try {
            const zip = new window.JSZip();
            
            // ä½¿ç”¨å»èƒŒå¾Œçš„åœ–ç‰‡ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰ï¼Œå¦å‰‡ä½¿ç”¨åŸå§‹åœ–ç‰‡
            const imagesToPack = processedImages.length > 0 ? processedImages : generatedImages.filter(img => img.status === 'success');

            if (imagesToPack.length === 0) {
                setError("æ²’æœ‰å¯ä»¥æ‰“åŒ…çš„è²¼åœ–ã€‚");
                return;
            }

            const imagePromises = imagesToPack.map(async (img) => {
                const imageUrl = img.processedImageUrl || img.imageUrl;
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                const suffix = img.isProcessed ? '-transparent' : '';
                const fileName = `sticker-${img.id.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`;
                zip.file(fileName, blob);
            });

            await Promise.all(imagePromises);

            const content = await zip.generateAsync({ type: "blob" });
            
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = processedImages.length > 0 ? "ai-sticker-pack-transparent.zip" : "ai-sticker-pack.zip";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);

        } catch (err) {
            console.error("å»ºç«‹å£“ç¸®æª”æ™‚ç™¼ç”ŸéŒ¯èª¤:", err);
            setError("å»ºç«‹å£“ç¸®æª”å¤±æ•—ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚");
        } finally {
            setIsZipping(false);
        }
    };
    
    const handleStartOver = () => {
        setGeneratedImages([]);
        setUploadedImage(null);
        setError(null);
        setCustomStickerPack([]); // æ¸…é™¤å®¢è£½åŒ–è²¼åœ–
        setCustomIdeaInput('');
        setSuggestedThemes([]);
        setSelectedStickers(defaultStickerPack.prompts.map(p => p.id)); // é‡è¨­ç‚ºé è¨­
        setProcessedImages([]); // æ¸…é™¤å»èƒŒå¾Œçš„åœ–ç‰‡
        setRemoveBgProgress(0); // é‡è¨­å»èƒŒé€²åº¦
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

    // ä¸€éµå»èƒŒåŠŸèƒ½
    const handleRemoveBackground = async () => {
        const successfulImages = generatedImages.filter(img => img.status === 'success');
        
        if (successfulImages.length === 0) {
            setError("æ²’æœ‰å¯ä»¥è™•ç†çš„è²¼åœ–ã€‚");
            return;
        }

        setIsRemovingBackground(true);
        setRemoveBgProgress(0);
        setError(null);
        setProcessedImages([]);

        try {
            const processedResults = [];
            
            for (let i = 0; i < successfulImages.length; i++) {
                const img = successfulImages[i];
                try {
                    const processedImageUrl = await removeBackground(img.imageUrl);
                    processedResults.push({
                        ...img,
                        processedImageUrl,
                        isProcessed: true
                    });
                } catch (err) {
                    console.error(`å»èƒŒå¤±æ•— ${img.id}:`, err);
                    processedResults.push({
                        ...img,
                        processedImageUrl: img.imageUrl, // ä½¿ç”¨åŸå§‹åœ–ç‰‡
                        isProcessed: false
                    });
                }
                
                // æ›´æ–°é€²åº¦
                const progress = ((i + 1) / successfulImages.length) * 100;
                setRemoveBgProgress(progress);
                
                // æ·»åŠ å°å»¶é²ä»¥é¡¯ç¤ºé€²åº¦
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            setProcessedImages(processedResults);
            
        } catch (err) {
            console.error("å»èƒŒè™•ç†å¤±æ•—:", err);
            setError("å»èƒŒè™•ç†å¤±æ•—ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚");
        } finally {
            setIsRemovingBackground(false);
        }
    };

    // âœ¨ æ–°å¢ï¼šå‘¼å« Gemini æ–‡å­—æ¨¡å‹ä¾†ç”Ÿæˆè²¼åœ–é»å­
    const handleGenerateIdeas = async () => {
        if (!customIdeaInput.trim()) {
            setError("è«‹è¼¸å…¥æ‚¨çš„è²¼åœ–é»å­æè¿°ï¼");
            return;
        }
        setIsGeneratingIdeas(true);
        setError(null);
        setCustomStickerPack([]);
        setSuggestedThemes([]);

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const systemPrompt = `You are a creative assistant that generates fun and expressive chat sticker ideas. Based on the user's description, provide a list of 6 to 8 sticker ideas. Each idea MUST include:
1.  A short, descriptive \`id\` in Traditional Chinese (e.g., 'å–å’–å•¡', 'æ‰“é›»å‹•'). This will be the user-facing name.
2.  A detailed \`base\` prompt in English for an image generation model (e.g., 'happily sipping a large mug of coffee, looking energized').
3.  A short, catchy, English \`memeText\` (e.g., 'COFFEE!', 'GAME ON').

Your response MUST be a valid JSON array of objects, following this exact schema. Do not include any other text or markdown formatting.`;

        const payload = {
            contents: [{ parts: [{ text: customIdeaInput }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "id": { "type": "STRING" },
                            "base": { "type": "STRING" },
                            "memeText": { "type": "STRING" }
                        },
                        required: ["id", "base", "memeText"]
                    }
                }
            }
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API request failed with status ${response.status}`);
            }

            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (jsonText) {
                const ideas = JSON.parse(jsonText);
                setCustomStickerPack(ideas);
                setSelectedStickers(ideas.map(idea => idea.id)); // è‡ªå‹•å…¨é¸æ–°çš„é»å­
            } else {
                throw new Error("API did not return valid JSON content.");
            }
        } catch (err) {
            console.error("ç”Ÿæˆè²¼åœ–é»å­å¤±æ•—:", err);
            setError("ç„¡æ³•ç”¢ç”Ÿè²¼åœ–é»å­ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
        } finally {
            setIsGeneratingIdeas(false);
        }
    };
    
    // âœ¨ æ–°å¢ï¼šå¾åœ–ç‰‡å–å¾—ä¸»é¡Œå»ºè­°ï¼ˆå¤šæ¨¡æ…‹ï¼‰
    const handleGetInspirationFromImage = async () => {
        if (!uploadedImage) {
            setError("è«‹å…ˆä¸Šå‚³ä¸€å¼µç…§ç‰‡æ‰èƒ½å–å¾—éˆæ„Ÿï¼");
            return;
        }
        setIsSuggestingThemes(true);
        setError(null);
        setSuggestedThemes([]);

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
        const imageWithoutPrefix = uploadedImage.split(',')[1];
        const textPrompt = `Analyze the person, their expression, clothing, and any notable objects or background in this image. Suggest 3 creative, short, and fun themes for a sticker pack based on what you see. For example, if you see a cat, suggest 'è²“å¥´æ—¥å¸¸'. If you see someone in a suit, suggest 'è¾¦å…¬å®¤é¢¨é›²'. Return your answer as a simple JSON array of strings, like \`["ä¸»é¡Œä¸€", "ä¸»é¡ŒäºŒ", "ä¸»é¡Œä¸‰"]\`. Only return the JSON array.`;

        const payload = {
            contents: [{
                parts: [
                    { text: textPrompt },
                    { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }
                ]
            }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: { type: "ARRAY", items: { type: "STRING" } }
            }
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
             if (!response.ok) {
                throw new Error(`API request failed with status ${response.status}`);
            }

            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (jsonText) {
                const themes = JSON.parse(jsonText);
                setSuggestedThemes(themes);
            } else {
                throw new Error("API did not return valid theme suggestions.");
            }
        } catch(err) {
            console.error("å¾åœ–ç‰‡å–å¾—å»ºè­°å¤±æ•—:", err);
            setError("ç„¡æ³•å¾åœ–ç‰‡å–å¾—å»ºè­°ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
        } finally {
            setIsSuggestingThemes(false);
        }
    };


    const progress = generatedImages.length > 0
        ? (generatedImages.filter(img => img.status !== 'pending').length / generatedImages.length) * 100
        : 0;
    
    return (
        <>
            <style>{`
              @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&family=Inter:wght@400;500;600;700;900&display=swap');
              
              body { font-family: 'Inter', sans-serif; background-color: #000000; }
              .font-caveat { font-family: 'Caveat', cursive; }
              .bg-grid-pattern { background-image: linear-gradient(rgba(255,255,255,0.07) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.07) 1px, transparent 1px); background-size: 20px 20px; }
              
              @keyframes fade-in-down {
                0% { opacity: 0; transform: translateY(-20px) translateX(-50%); }
                100% { opacity: 1; transform: translateY(0) translateX(-50%); }
              }
              .animate-fade-in-down { animation: fade-in-down 0.5s ease-out forwards; }
              
              .custom-checkbox:checked {
                background-color: #FBBF24;
                border-color: #FBBF24;
              }
              .custom-checkbox:checked::after {
                opacity: 1;
              }
            `}</style>
            
            <CameraModal
                isOpen={isCameraOpen}
                onClose={() => setIsCameraOpen(false)}
                onCapture={handleCaptureConfirm}
            />

            <div className="bg-black text-gray-200 min-h-screen flex flex-col items-center p-4 pb-20">
                 <ErrorNotification message={error} onDismiss={() => setError(null)} />
                
                <div className="w-full max-w-6xl mx-auto">
                    
                    <header className="text-center my-12">
                        <h1 className="text-6xl md:text-7xl font-bold text-white tracking-tight">
                            One Click <span className="text-yellow-400">Sticker 2.0</span>
                        </h1>
                        <p className="mt-4 text-lg text-gray-500">å°‡æ‚¨çš„ç…§ç‰‡è®Šæˆç¨ä¸€ç„¡äºŒçš„èŠå¤©è²¼åœ–ã€‚</p>
                    </header>

                    <main>
                        <div className="bg-gray-900/50 backdrop-blur-sm p-8 rounded-2xl shadow-2xl border border-gray-800 mb-16">
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-10">

                                <div>
                                    <h2 className="text-2xl font-semibold mb-6 text-white">1. æ‚¨çš„ç…§ç‰‡</h2>
                                    <div 
                                        className="w-full aspect-square border-4 border-dashed border-gray-700 rounded-xl flex items-center justify-center cursor-pointer hover:border-yellow-400 transition-colors bg-gray-800 overflow-hidden shadow-inner"
                                        onClick={() => !uploadedImage && fileInputRef.current && fileInputRef.current.click()}
                                    >
                                        {isUploading ? (
                                            <div className="flex flex-col items-center">
                                                <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-yellow-400"></div>
                                                <p className="text-gray-400 mt-4">ä¸Šå‚³ä¸­...</p>
                                            </div>
                                        ) : uploadedImage ? (
                                            <img src={uploadedImage} alt="ä¸Šå‚³é è¦½" className="w-full h-full object-cover" />
                                        ) : (
                                            <div className="flex flex-col items-center justify-center p-6 text-center text-gray-500">
                                                <IconUpload />
                                                <p className="mt-4 text-lg text-gray-300">é»æ“Šä»¥ä¸Šå‚³æª”æ¡ˆ</p>
                                                <p className="mt-4 text-sm">æˆ–</p>
                                                <Button
                                                    onClick={(e) => {
                                                        e.stopPropagation(); 
                                                        setIsCameraOpen(true);
                                                    }}
                                                    className="mt-2"
                                                >
                                                    <div className="flex items-center gap-2">
                                                        <IconCamera />
                                                        <span>ä½¿ç”¨ç›¸æ©Ÿ</span>
                                                    </div>
                                                </Button>
                                            </div>
                                        )}
                                    </div>
                                    {uploadedImage && !isUploading && (
                                        <div className="flex flex-col sm:flex-row gap-4 mt-4 w-full">
                                            <Button onClick={() => fileInputRef.current && fileInputRef.current.click()} className="flex-1">
                                                æ›´æ›æª”æ¡ˆ
                                            </Button>
                                            <Button onClick={() => setIsCameraOpen(true)} className="flex-1">
                                                <div className="flex items-center justify-center gap-2">
                                                    <IconCamera />
                                                    <span>ä½¿ç”¨ç›¸æ©Ÿ</span>
                                                </div>
                                            </Button>
                                        </div>
                                    )}
                                     <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/png, image/jpeg" className="hidden" />
                                </div>

                                <div>
                                     <h2 className="text-2xl font-semibold mb-6 text-white">2. é¸æ“‡è²¼åœ–</h2>
                                     
                                     {/* âœ¨ Gemini LLM åŠŸèƒ½å€å¡Š */}
                                     <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700 mb-6">
                                        <h3 className="font-semibold text-lg mb-2 text-yellow-300">âœ¨ AI è²¼åœ–å‰µæ„ç”¢ç”Ÿå™¨</h3>
                                        <p className="text-gray-400 text-sm mb-3">æè¿°ä¸€å€‹ä¸»é¡Œï¼Œæˆ–è®“ AI å¾æ‚¨çš„ç…§ç‰‡æ‰¾éˆæ„Ÿï¼</p>
                                        
                                        {/* âœ¨ æ–°å¢ï¼šå¾åœ–ç‰‡å–å¾—éˆæ„Ÿ */}
                                        <div className="mb-3">
                                            <Button onClick={handleGetInspirationFromImage} disabled={!uploadedImage || isSuggestingThemes} className="w-full">
                                                <div className="flex items-center justify-center gap-2">
                                                {isSuggestingThemes ? (
                                                    <>
                                                        <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-gray-300"></div>
                                                        <span>åˆ†æä¸­...</span>
                                                    </>
                                                ) : (
                                                    <>
                                                        <IconSparkles />
                                                        <span>å¾åœ–ç‰‡å–å¾—éˆæ„Ÿ</span>
                                                    </>
                                                )}
                                                </div>
                                            </Button>
                                            {suggestedThemes.length > 0 && (
                                                <div className="flex flex-wrap gap-2 mt-3">
                                                    {suggestedThemes.map(theme => (
                                                        <button 
                                                            key={theme} 
                                                            onClick={() => {
                                                                setCustomIdeaInput(theme);
                                                                handleGenerateIdeas();
                                                            }}
                                                            className="px-3 py-1 bg-gray-700 text-sm rounded-full hover:bg-gray-600"
                                                        >{theme}</button>
                                                    ))}
                                                </div>
                                            )}
                                        </div>

                                        <textarea 
                                            value={customIdeaInput}
                                            onChange={(e) => setCustomIdeaInput(e.target.value)}
                                            placeholder="ä¾‹å¦‚ï¼šæˆ‘å®¶æ„›æ—è›‹çš„æ©˜è²“ã€è¾¦å…¬å®¤å°ˆç”¨..."
                                            className="w-full bg-gray-900 border border-gray-600 rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-yellow-400 text-white text-sm"
                                            rows="2"
                                        />
                                        <Button onClick={handleGenerateIdeas} disabled={isGeneratingIdeas} primary className="w-full mt-3">
                                            <div className="flex items-center justify-center gap-2">
                                                {isGeneratingIdeas ? (
                                                    <>
                                                        <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div>
                                                        <span>ç”¢ç”Ÿä¸­...</span>
                                                    </>
                                                ) : (
                                                    "ç”¢ç”Ÿé»å­"
                                                )}
                                            </div>
                                        </Button>
                                     </div>

                                      <div className="flex justify-between items-center mb-4">
                                        <p className="text-gray-400">é¸æ“‡æ‚¨æƒ³ç”Ÿæˆçš„åæ‡‰ï¼š</p>
                                        {customStickerPack.length > 0 && (
                                            <button 
                                                onClick={() => {
                                                    setCustomStickerPack([]);
                                                    setSelectedStickers(defaultStickerPack.prompts.map(p => p.id));
                                                }}
                                                className="text-xs text-yellow-400 hover:text-yellow-300"
                                            >
                                                â† è¿”å›é è¨­è²¼åœ–
                                            </button>
                                        )}
                                      </div>
                                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                                         {activeStickerPack.map(prompt => (
                                             <label key={prompt.id} className={`cursor-pointer p-3 rounded-lg border-2 text-center transition-colors duration-200 ${selectedStickers.includes(prompt.id) ? 'bg-yellow-400/20 border-yellow-400 text-white' : 'bg-gray-800 border-gray-700 hover:border-gray-600 text-gray-300'}`}>
                                                 <input
                                                     type="checkbox"
                                                     checked={selectedStickers.includes(prompt.id)}
                                                     onChange={() => handleStickerSelection(prompt.id)}
                                                     className="hidden"
                                                 />
                                                 <span className="font-semibold text-sm">{prompt.id}</span>
                                             </label>
                                         ))}
                                     </div>
                                      <div className="flex items-center space-x-6 mt-6">
                                        <div className="flex items-center">
                                            <input 
                                                type="checkbox" 
                                                id="addTextCheck"
                                                checked={addText}
                                                onChange={(e) => setAddText(e.target.checked)}
                                                className="custom-checkbox relative peer shrink-0 appearance-none w-5 h-5 border-2 border-gray-500 rounded-sm bg-gray-800 transition-colors after:absolute after:left-0 after:top-0 after:h-full after:w-full after:bg-no-repeat after:bg-center after:opacity-0 after:content-['âœ”'] after:text-black after:text-sm"
                                            />
                                            <label htmlFor="addTextCheck" className="ml-3 text-gray-300 cursor-pointer">åŠ ä¸Šæ–‡å­—</label>
                                        </div>
                                        <div className="flex items-center">
                                            <input 
                                                type="checkbox" 
                                                id="isDynamicCheck"
                                                checked={isDynamic}
                                                onChange={(e) => setIsDynamic(e.target.checked)}
                                                className="custom-checkbox relative peer shrink-0 appearance-none w-5 h-5 border-2 border-gray-500 rounded-sm bg-gray-800 transition-colors after:absolute after:left-0 after:top-0 after:h-full after:w-full after:bg-no-repeat after:bg-center after:opacity-0 after:content-['âœ”'] after:text-black after:text-sm"
                                            />
                                            <label htmlFor="isDynamicCheck" className="ml-3 text-gray-300 cursor-pointer">å‹•æ…‹é è¦½</label>
                                        </div>
                                     </div>
                                </div>
                            </div>

                            <div className="mt-12 text-center">
                                <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                                    <Button
                                        onClick={handleGenerateClick}
                                        disabled={!uploadedImage || isLoading || isUploading}
                                        primary
                                        className="text-lg px-12 py-4"
                                    >
                                        <div className="flex items-center gap-3">
                                            {isLoading ? (
                                                <>
                                                    <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div>
                                                    {`ç”Ÿæˆä¸­... (${Math.round(progress)}%)`}
                                                </>
                                            ) : (
                                                <>
                                                    <IconSparkles />
                                                    ç”Ÿæˆè²¼åœ–
                                                </>
                                            )}
                                        </div>
                                    </Button>
                                    
                                    {/* ä¸€éµå»èƒŒæŒ‰éˆ• - åªåœ¨æœ‰æˆåŠŸç”Ÿæˆçš„è²¼åœ–æ™‚é¡¯ç¤º */}
                                    {!isLoading && generatedImages.some(img => img.status === 'success') && (
                                        <div className="flex flex-col items-center gap-2">
                                            <Button
                                                onClick={handleRemoveBackground}
                                                disabled={isRemovingBackground}
                                                className="text-lg px-8 py-4 bg-green-600 hover:bg-green-500 text-white"
                                            >
                                                <div className="flex items-center gap-3">
                                                    {isRemovingBackground ? (
                                                        <>
                                                            <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white"></div>
                                                            {`å»èƒŒä¸­... (${Math.round(removeBgProgress)}%)`}
                                                        </>
                                                    ) : (
                                                        <>
                                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                                                                <path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-3.876a1.5 1.5 0 0 0-4.471-4.471L9.53 16.122ZM21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                                                            </svg>
                                                            ä¸€éµå»èƒŒ
                                                        </>
                                                    )}
                                                </div>
                                            </Button>
                                            <p className="text-xs text-gray-400 text-center max-w-xs">
                                                æ™ºèƒ½å»é™¤äº®ç¶ è‰²èƒŒæ™¯ï¼Œä¿ç•™äººç‰©ç´°ç¯€
                                            </p>
                                        </div>
                                    )}
                                </div>
                                
                                {/* å»èƒŒé€²åº¦æ¢ */}
                                {isRemovingBackground && (
                                    <div className="w-full max-w-md mx-auto mt-4">
                                        <div className="bg-gray-800 rounded-full h-3 overflow-hidden shadow-md">
                                            <motion.div
                                                className="bg-green-500 h-3 rounded-full"
                                                initial={{ width: 0 }}
                                                animate={{ width: `${removeBgProgress}%` }}
                                                transition={{ duration: 0.3 }}
                                            />
                                        </div>
                                                        <p className="text-gray-400 mt-2 text-sm">æ­£åœ¨å»é™¤äº®ç¶ è‰²èƒŒæ™¯ï¼Œè«‹ç¨å€™...</p>
                                    </div>
                                )}
                            </div>
                        </div>


                        <div ref={resultsRef}>
                            {(isLoading || generatedImages.length > 0) && (
                                <div className="mt-16">
                                    <h2 className="text-3xl font-bold text-white mb-8 text-center">æ‚¨ç”Ÿæˆçš„è²¼åœ–</h2>

                                    {isLoading && (
                                        <div className="w-full max-w-4xl mx-auto mb-8 text-center">
                                            <div className="bg-gray-800 rounded-full h-3 overflow-hidden shadow-md">
                                                <motion.div
                                                    className="bg-yellow-400 h-3 rounded-full"
                                                    initial={{ width: 0 }}
                                                    animate={{ width: `${progress}%` }}
                                                    transition={{ duration: 0.5 }}
                                                />
                                            </div>
                                            <p className="text-gray-400 mt-4 text-sm">ç”Ÿæˆè²¼åœ–æ™‚è«‹ä¿æŒæ­¤è¦–çª—é–‹å•Ÿã€‚</p>
                                        </div>
                                    )}
                                     <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-6 mt-8">
                                        {generatedImages.map((img, index) => {
                                            switch (img.status) {
                                                case 'success':
                                                    // æª¢æŸ¥æ˜¯å¦æœ‰å»èƒŒå¾Œçš„ç‰ˆæœ¬
                                                    const processedImg = processedImages.find(p => p.id === img.id);
                                                    const displayImageUrl = processedImg ? processedImg.processedImageUrl : img.imageUrl;
                                                    const isProcessed = processedImg ? processedImg.isProcessed : false;
                                                    
                                                    return <StickerDisplay
                                                        key={`${img.id}-${index}-success`}
                                                        emotion={img.id}
                                                        imageUrl={displayImageUrl}
                                                        onDownload={(url, emotion) => handleDownloadRequest(url, emotion, isProcessed)}
                                                        onRegenerate={() => regenerateImageAtIndex(index)}
                                                        isDynamic={isDynamic}
                                                        isProcessed={isProcessed}
                                                    />;
                                                case 'failed':
                                                    return <ErrorCard
                                                        key={`${img.id}-${index}-failed`}
                                                        emotion={img.id}
                                                        onRegenerate={() => regenerateImageAtIndex(index)}
                                                    />;
                                                case 'pending':
                                                default:
                                                    return <LoadingCard 
                                                        key={`${img.id}-${index}-pending`} 
                                                        emotion={img.id} />;
                                            }
                                        })}
                                    </div>
                                </div>
                            )}

                            {!isLoading && generatedImages.length > 0 && (
                                <div className="text-center mt-16 mb-12 flex flex-col sm:flex-row items-center justify-center gap-6">
                                    <Button onClick={handleStartOver}>é‡æ–°é–‹å§‹</Button>
                                    <Button onClick={handleDownloadAllAsZip} primary disabled={isZipping}>
                                        <div className="flex items-center gap-2">
                                        {isZipping ? (
                                            <>
                                               <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div>
                                               <span>æ‰“åŒ…ä¸­...</span>
                                            </>
                                        ) : (
                                            <>
                                                <IconZip />
                                                <span>æ‰“åŒ…ä¸‹è¼‰</span>
                                            </>
                                        )}
                                        </div>
                                    </Button>
                                </div>
                            )}
                        </div>
                    </main>
                    
                    {/* åº•éƒ¨é€£çµæŒ‰éˆ•å€åŸŸ */}
                    <footer className="mt-20 mb-8">
                        <div className="text-center">
                            <h3 className="text-xl font-semibold text-gray-300 mb-6">æ›´å¤šç²¾å½©å·¥å…·</h3>
                            <div className="flex flex-wrap justify-center gap-4">
                                <a
                                    href="https://www.youtube.com/watch?v=FXVu-1zmeKo"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-red-600 hover:bg-red-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" className="w-5 h-5">
                                        <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                                    </svg>
                                    ä¸€éµæ›è‡‰
                                </a>
                                
                                <a
                                    href="https://youtu.be/8M68FaiZ3I4?si=-5VXfob07bGVN_tL"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-purple-600 hover:bg-purple-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                                        <path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-3.876a1.5 1.5 0 0 0-4.471-4.471L9.53 16.122ZM21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                                    </svg>
                                    ä¸€éµå…‹éš†é¢¨æ ¼
                                </a>
                                
                                <a
                                    href="https://novelpd.online/"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                                        <path strokeLinecap="round" strokeLinejoin="round" d="M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25" />
                                    </svg>
                                    AIå°èªªç”Ÿæˆ
                                </a>
                                
                                <a
                                    href="https://www.facebook.com/profile.php?id=61556209555154"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" className="w-5 h-5">
                                        <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                                    </svg>
                                    åŸå‰µ-æ¬£æ¬£
                                </a>
                                
                                <a
                                    href="https://x.com/ririkaDDC"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-gray-800 hover:bg-gray-700 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" className="w-5 h-5">
                                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                                    </svg>
                                    Ririka X
                                </a>
                            </div>
                        </div>
                    </footer>
                </div>
            </div>
        </>
    );
};

export default App;

