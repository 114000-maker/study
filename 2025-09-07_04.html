<!---
👇One Click Sticker影片介紹👇https://youtu.be/JJGgQ7tKb0U
-->

import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';
import { motion } from 'framer-motion';

// --- 輔助函式 ---

// 將檔案轉換為 Base64
const toBase64 = file => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = error => reject(error);
});

// 帶有重試機制的 fetch 函式
const fetchWithRetry = (url, options, retries = 5, backoff = 1000) => {
    return new Promise((resolve, reject) => {
        const attempt = async (retryCount, delay) => {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API 錯誤:', errorData);
                    if (response.status === 429 && retryCount > 0) {
                        console.log(`請求頻率過高。將在 ${delay / 1000} 秒後重試...`);
                        setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                    } else if (response.status === 401) {
                        reject(new Error(`API 請求失敗，狀態碼 401：未授權。請確認您的 API 金鑰是否有效。`));
                    }
                    else {
                        reject(new Error(`API 請求失敗，狀態碼 ${response.status}: ${errorData.error?.message || '未知錯誤'}`));
                    }
                } else {
                    resolve(response.json());
                }
            } catch (error) {
                if (retryCount > 0) {
                    console.log(`請求失敗。將在 ${delay / 1000} 秒後重試...`, error);
                    setTimeout(() => attempt(retryCount - 1, delay * 2), delay);
                } else {
                    reject(error);
                }
            }
        };
        attempt(retries, backoff);
    });
};

// 帶有重試機制的圖片生成函式
const generateImageWithRetry = async (payload, totalAttempts = 3) => {
    let lastError;
    for (let attempt = 1; attempt <= totalAttempts; attempt++) {
        try {
            const apiKey = ""; // Canvas 環境會自動處理空的金鑰

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
            
            const result = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

            if (base64Data) {
                return `data:image/png;base64,${base64Data}`;
            }

            lastError = new Error("API 未返回圖片資料。");
            console.warn(`第 ${attempt}/${totalAttempts} 次嘗試: ${lastError.message}`);

        } catch (error) {
            lastError = error;
            console.error(`第 ${attempt}/${totalAttempts} 次嘗試失敗:`, error);
        }

        if (attempt < totalAttempts) {
            const delay = 2500 * Math.pow(2, attempt - 1);
            console.log(`等待 ${delay / 1000} 秒後進行下一次嘗試...`);
            await new Promise(res => setTimeout(res, delay));
        }
    }

    throw new Error(`圖片生成在 ${totalAttempts} 次嘗試後失敗。最後錯誤: ${lastError?.message || '未知錯誤'}`);
};

// 改進的去背功能 - 使用多種方法確保背景去除
const removeBackground = (imageUrl) => {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.width;
            canvas.height = img.height;
            
            // 繪製原始圖片
            ctx.drawImage(img, 0, 0);
            
            // 獲取圖片數據
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 調試：收集一些顏色樣本
            const colorSamples = [];
            let sampleCount = 0;
            
            // 背景去除算法 - 檢測亮綠色背景並設為透明
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // 收集一些顏色樣本用於調試
                if (sampleCount < 10 && Math.random() < 0.001) {
                    colorSamples.push({ r, g, b, a });
                    sampleCount++;
                }
                
                // 使用 HSV 色彩空間檢測綠色背景
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;
                
                // 計算色相 (Hue)
                let hue = 0;
                if (delta !== 0) {
                    if (max === g) {
                        hue = 60 * ((b - r) / delta + 2);
                    } else if (max === r) {
                        hue = 60 * ((g - b) / delta + 4);
                    } else {
                        hue = 60 * ((r - g) / delta);
                    }
                }
                if (hue < 0) hue += 360;
                
                // 計算飽和度和明度
                const saturation = max === 0 ? 0 : delta / max;
                const value = max / 255;
                
                // 檢測綠色背景的多種條件
                const isGreenHue = (hue >= 60 && hue <= 180); // 綠色色相範圍
                const isHighSaturation = saturation > 0.3;    // 高飽和度
                const isBright = value > 0.4;                 // 足夠明亮
                const isGreenDominant = (g > r + 30 && g > b + 30); // 綠色主導
                
                // 檢測邊緣像素
                const pixelIndex = i / 4;
                const x = pixelIndex % canvas.width;
                const y = Math.floor(pixelIndex / canvas.width);
                const isEdgePixel = (
                    x < 15 || x > canvas.width - 15 || 
                    y < 15 || y > canvas.height - 15
                );
                
                // 綜合判斷是否為背景
                const isBackground = (
                    // 條件1：綠色色相 + 高飽和度 + 足夠明亮
                    (isGreenHue && isHighSaturation && isBright) ||
                    // 條件2：邊緣區域的綠色主導像素
                    (isEdgePixel && isGreenDominant && g > 100) ||
                    // 條件3：非常亮的綠色
                    (g > 200 && r < 50 && b < 50) ||
                    // 條件4：純綠色或接近純綠色
                    (Math.abs(r - 0) < 20 && Math.abs(g - 255) < 20 && Math.abs(b - 0) < 20)
                );
                
                if (isBackground) {
                    data[i + 3] = 0; // 設 alpha 為 0（透明）
                }
            }
            
            // 調試輸出
            console.log('去背處理 - 顏色樣本:', colorSamples);
            
            // 檢查是否有足夠的透明像素被創建
            let transparentPixels = 0;
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] === 0) transparentPixels++;
            }
            const transparencyRatio = transparentPixels / (data.length / 4);
            console.log(`去背結果: ${Math.round(transparencyRatio * 100)}% 的像素被設為透明`);
            
            // 如果透明像素太少，嘗試備用方法
            if (transparencyRatio < 0.1) {
                console.log('亮綠色檢測效果不佳，嘗試備用去背方法...');
                
                // 備用方法：檢測邊緣區域的主要顏色
                const edgeColors = [];
                const edgeSize = 5;
                
                // 收集邊緣顏色
                for (let y = 0; y < edgeSize; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        edgeColors.push({
                            r: data[idx],
                            g: data[idx + 1],
                            b: data[idx + 2]
                        });
                    }
                }
                
                // 找到最常見的邊緣顏色
                const colorCounts = {};
                edgeColors.forEach(color => {
                    const key = `${Math.floor(color.r/20)*20},${Math.floor(color.g/20)*20},${Math.floor(color.b/20)*20}`;
                    colorCounts[key] = (colorCounts[key] || 0) + 1;
                });
                
                const mostCommonColor = Object.keys(colorCounts).reduce((a, b) => 
                    colorCounts[a] > colorCounts[b] ? a : b
                );
                const [targetR, targetG, targetB] = mostCommonColor.split(',').map(Number);
                
                console.log('檢測到的主要背景顏色:', { r: targetR, g: targetG, b: targetB });
                
                // 使用檢測到的主要顏色進行去背
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    const colorDistance = Math.sqrt(
                        Math.pow(r - targetR, 2) + 
                        Math.pow(g - targetG, 2) + 
                        Math.pow(b - targetB, 2)
                    );
                    
                    // 如果顏色接近主要背景顏色，設為透明
                    if (colorDistance < 50) {
                        data[i + 3] = 0;
                    }
                }
            }
            
            // 將處理後的數據放回 canvas
            ctx.putImageData(imageData, 0, 0);
            
            // 轉換為 base64
            const processedImageUrl = canvas.toDataURL('image/png');
            resolve(processedImageUrl);
        };
        
        img.onerror = () => {
            reject(new Error('圖片載入失敗'));
        };
        
        img.src = imageUrl;
    });
};


/**
 * 圖片生成指令
 */
const getModelInstruction = (prompt, addText) => {
    let instruction = `The highest priority is to maintain the exact facial features, likeness, and perceived gender of the person in the provided reference photo.
Transform the person into a cute, expressive 1:1 aspect ratio chat sticker based on the following action: "${prompt.base}".
The sticker MUST have a thick, clean white outline and a subtle drop shadow to make it pop.
The sticker MUST have a solid, bright lime green background (RGB: 0, 255, 0) - this is crucial for background removal later.
The final image should be a high-quality PNG.
Do not alter the person's core facial structure.`;

    if (addText && prompt.memeText) {
        instruction += `\nAdditionally, incorporate the text "${prompt.memeText}" into the sticker design in a fun, stylized, and readable English font that matches the emotion. The text should be easily visible against the bright lime green background.`;
    }

    return instruction;
};

// --- 圖示 ---

const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-10 h-10"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /></svg>;
const IconSparkles = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" /></svg>;
const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>;
const IconCamera = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 0 0-1.134-.175 2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.776 48.776 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.039l-.821 1.316Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0ZM18.75 10.5h.008v.008h-.008V10.5Z" /></svg>;
const IconZip = () => <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125z" /></svg>;


// --- React 元件 (重新設計與簡化) ---

const Button = ({ children, onClick, disabled, primary = false, className = '' }) => {
    const baseClass = "px-6 py-2 rounded-md font-semibold tracking-wider uppercase transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed";
    const themeClass = primary 
        ? "bg-yellow-400 text-black hover:bg-yellow-300" 
        : "bg-transparent border border-gray-600 text-gray-300 hover:bg-gray-800 hover:text-white";
    
    return (
        <button
            onClick={onClick}
            disabled={disabled}
            className={`${baseClass} ${themeClass} ${className}`}
        >
            {children}
        </button>
    );
};

// 專為貼圖設計的簡化顯示卡
const StickerDisplay = ({ emotion, imageUrl, onDownload, onRegenerate, isDynamic, isProcessed = false }) => {
    return (
        <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
            whileHover={isDynamic ? { y: -8, rotate: Math.random() * 6 - 3 } : {}}
            className="relative group p-4 bg-gray-900/50 rounded-xl shadow-lg transition-all duration-300 hover:shadow-2xl border border-gray-800"
        >
            <div className="aspect-square bg-grid-pattern flex items-center justify-center rounded-lg relative">
                <img src={imageUrl} alt={`貼圖表情 ${emotion}`} className="w-full h-full object-contain" />
                {/* 去背狀態指示器 */}
                {isProcessed && (
                    <div className="absolute top-2 left-2 bg-green-500 text-white text-xs px-2 py-1 rounded-full font-semibold">
                        透明背景
                    </div>
                )}
            </div>
            <p className="text-center mt-3 text-lg font-semibold text-gray-300 px-3">{emotion}</p>
            
            <div className="absolute top-3 right-3 z-10 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
                <button
                    onClick={onRegenerate}
                    className="p-2 rounded-full bg-black/60 text-white hover:bg-black/80 transition-colors backdrop-blur-sm shadow-lg"
                    aria-label="重新生成貼圖"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5"><path strokeLinecap="round" strokeLinejoin="round" d="M16.023 16.023A7.5 7.5 0 1 0 8.25 8.25V6.75a.75.75 0 0 1 1.5 0v3.75a.75.75 0 0 1-.75.75H5.25a.75.75 0 0 1 0-1.5h2.37a5.98 5.98 0 0 1 8.403 8.403Z" /></svg>
                </button>
                <button
                    onClick={() => onDownload(imageUrl, emotion)}
                    className="p-2 rounded-full bg-black/60 text-white hover:bg-black/80 transition-colors backdrop-blur-sm shadow-lg"
                    aria-label="下載貼圖"
                >
                    <IconDownload />
                </button>
            </div>
        </motion.div>
    );
};

const SkeletonLoader = ({ className }) => (
    <div className={`animate-pulse bg-gray-800 ${className}`}></div>
);

// 專為貼圖設計的簡化載入卡
const LoadingCard = ({ emotion }) => {
    return (
        <div className="p-4 bg-gray-900 rounded-xl shadow-md">
            <div className="aspect-square bg-grid-pattern rounded-lg relative flex items-center justify-center">
                 <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-yellow-400"></div>
            </div>
            <div className="mt-3 flex justify-center">
                <SkeletonLoader className="h-5 w-1/2 rounded-md" />
            </div>
        </div>
    );
};

// 專為貼圖設計的簡化錯誤卡
const ErrorCard = ({ emotion, onRegenerate }) => {
    return (
        <div className="p-4 bg-gray-900 rounded-xl shadow-md border border-red-500/30">
            <div className="aspect-square bg-grid-pattern rounded-lg flex flex-col items-center justify-center text-center p-4 border-2 border-dashed border-red-500/50">
                 <p className="text-red-400 font-medium mb-4">生成失敗</p>
                 {onRegenerate && (
                     <Button onClick={onRegenerate} primary>
                         重試
                     </Button>
                 )}
            </div>
            <p className="text-center mt-3 text-lg font-semibold text-gray-300 px-3">{emotion}</p>
        </div>
    );
};


// 註：ErrorNotification 和 CameraModal 元件因為是獨立的，所以保持不變。
const ErrorNotification = ({ message, onDismiss }) => {
    if (!message) return null;
    return (
        <div className="fixed top-5 left-1/2 z-50 w-full max-w-md p-4 bg-gray-900 border border-gray-700 text-gray-300 rounded-lg shadow-2xl flex items-center justify-between animate-fade-in-down" style={{ transform: 'translateX(-50%)' }}>
            <span>{message}</span>
            <button onClick={onDismiss} className="p-1 rounded-full hover:bg-gray-800 transition-colors ml-4">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-500"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>
    );
};

const CameraModal = ({ isOpen, onClose, onCapture }) => {
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const streamRef = useRef(null);
    const [capturedImage, setCapturedImage] = useState(null);
    const [cameraError, setCameraError] = useState(null);

    const stopCamera = useCallback(() => {
        if (streamRef.current) {
            streamRef.current.getTracks().forEach(track => track.stop());
            streamRef.current = null;
        }
        if (videoRef.current) {
            videoRef.current.srcObject = null;
        }
    }, []);

    const startCamera = useCallback(async () => {
        if (videoRef.current) {
            setCameraError(null);
            try {
                stopCamera();
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1024 }, height: { ideal: 1024 }, facingMode: 'user' }
                });
                videoRef.current.srcObject = stream;
                streamRef.current = stream;
            } catch (err) {
                console.error("存取相機時發生錯誤:", err);
                setCameraError("相機存取被拒絕。請在您的瀏覽器設定中允許相機存取。");
            }
        }
    }, [stopCamera]);

    useEffect(() => {
        if (isOpen && !capturedImage) {
            startCamera();
        } else {
            stopCamera();
        }
        return () => {
            stopCamera();
        };
    }, [isOpen, capturedImage, startCamera, stopCamera]);


    const handleCapture = () => {
        if (videoRef.current && canvasRef.current) {
            const video = videoRef.current;
            const canvas = canvasRef.current;
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const context = canvas.getContext('2d');
            context.scale(-1, 1);
            context.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/png');
            setCapturedImage(dataUrl);
        }
    };

    const handleConfirm = () => {
        if (capturedImage) {
            onCapture(capturedImage);
            onClose();
        }
    };

    const handleRetake = () => {
        setCapturedImage(null);
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
             <motion.div 
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{ duration: 0.2 }}
                className="bg-gray-900 rounded-2xl p-6 border border-gray-700 shadow-2xl w-full max-w-2xl text-center relative"
             >
                <h3 className="text-2xl font-semibold mb-4 text-white">相機</h3>
                <div className="aspect-square bg-black rounded-lg overflow-hidden relative mb-4 flex items-center justify-center">
                    {cameraError ? (
                        <div className="p-4 text-red-400">{cameraError}</div>
                    ) : (
                        <>
                            {capturedImage ? (
                                <img src={capturedImage} alt="拍攝預覽" className="w-full h-full object-cover" />
                            ) : (
                                <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover transform -scale-x-100"></video>
                            )}
                        </>
                    )}
                </div>

                <div className="flex justify-center gap-4">
                    {capturedImage ? (
                        <>
                            <Button onClick={handleRetake}>重拍</Button>
                            <Button onClick={handleConfirm} primary>使用照片</Button>
                        </>
                    ) : (
                       <button onClick={handleCapture} disabled={!!cameraError} className="w-20 h-20 rounded-full bg-white border-4 border-gray-600 focus:outline-none focus:ring-4 focus:ring-yellow-400 transition-all hover:border-yellow-400 disabled:opacity-50 disabled:cursor-not-allowed"></button>
                    )}
                </div>
                
                <button onClick={onClose} className="absolute top-4 right-4 p-2 rounded-full bg-gray-800/70 text-white hover:bg-gray-700 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>
                </button>
                <canvas ref={canvasRef} className="hidden"></canvas>
            </motion.div>
        </div>
    );
};

const App = () => {
    // 核心狀態
    const [uploadedImage, setUploadedImage] = useState(null);
    const [generatedImages, setGeneratedImages] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const fileInputRef = useRef(null);
    const [isUploading, setIsUploading] = useState(false);
    const [isCameraOpen, setIsCameraOpen] = useState(false);
    const resultsRef = useRef(null);
    
    // 去背功能狀態
    const [isRemovingBackground, setIsRemovingBackground] = useState(false);
    const [removeBgProgress, setRemoveBgProgress] = useState(0);
    const [processedImages, setProcessedImages] = useState([]);
    
    // 貼圖選擇與選項狀態
    const [selectedStickers, setSelectedStickers] = useState([]);
    const [addText, setAddText] = useState(true);
    const [isDynamic, setIsDynamic] = useState(true);
    const [isZipping, setIsZipping] = useState(false);
    
    // Gemini 功能狀態
    const [customIdeaInput, setCustomIdeaInput] = useState('');
    const [customStickerPack, setCustomStickerPack] = useState([]);
    const [isGeneratingIdeas, setIsGeneratingIdeas] = useState(false);
    const [suggestedThemes, setSuggestedThemes] = useState([]);
    const [isSuggestingThemes, setIsSuggestingThemes] = useState(false);


    // 預設貼圖包定義
    const defaultStickerPack = useMemo(() => ({
        name: 'AI 貼圖包',
        description: '從您的照片生成有趣的聊天貼圖。',
        icon: '😜',
        prompts: [
            { id: '開心', base: 'a happy, joyful, smiling expression, maybe with stars in the eyes', memeText: 'YAY!' },
            { id: '傷心', base: 'a sad expression, with cartoonishly large tears streaming down the face', memeText: 'SO SAD' },
            { id: '大笑', base: 'laughing out loud hysterically, eyes squeezed shut', memeText: 'LOL' },
            { id: '生氣', base: 'an angry, fuming expression with red cheeks and steam coming out of the ears', memeText: 'GRRR' },
            { id: '愛心', base: 'an adoring expression with large heart-shaped eyes', memeText: 'UWU' },
            { id: 'OK', base: 'giving a cheerful thumbs-up sign', memeText: 'OK!' },
            { id: '問號', base: 'a confused expression with question marks floating around the head', memeText: '???' },
            { id: '想睡', base: 'a very sleepy, yawning expression with a snot bubble', memeText: 'Zzz...' },
            { id: '驚訝', base: 'a shocked, surprised expression with wide eyes and open mouth, like "wow"', memeText: 'WOW!' },
            { id: '思考', base: 'a thoughtful expression with a finger on the chin, looking upwards', memeText: 'Hmm...' },
            { id: '難過', base: 'a crying expression with a quivering lip, feeling wronged', memeText: 'SNIFF...' },
            { id: '拜託', base: 'a pleading expression with big, shimmering "puppy dog" eyes', memeText: 'Pls?' },
        ]
    }), []);
    
    const activeStickerPack = customStickerPack.length > 0 ? customStickerPack : defaultStickerPack.prompts;

    // 元件掛載時自動選擇所有貼圖並載入 JSZip
    useEffect(() => {
        setSelectedStickers(defaultStickerPack.prompts.map(p => p.id));
        
        const script = document.createElement('script');
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.async = true;
        document.body.appendChild(script);

        return () => {
            document.body.removeChild(script);
        };
    }, [defaultStickerPack]);


    const handleStickerSelection = (stickerId) => {
        setSelectedStickers(prev => 
            prev.includes(stickerId)
                ? prev.filter(id => id !== stickerId)
                : [...prev, stickerId]
        );
    };

    const regenerateImageAtIndex = async (imageIndex) => {
        const imageToRegenerate = generatedImages[imageIndex];
        if (!imageToRegenerate) return;
    
        setGeneratedImages(prev => prev.map((img, index) =>
            index === imageIndex ? { ...img, status: 'pending' } : img
        ));
        setError(null);
    
        const originalPrompts = activeStickerPack.filter(p => generatedImages.map(gi => gi.id).includes(p.id));
        const prompt = originalPrompts[imageIndex];

        if (!prompt) {
            setError("找不到要重新生成的提示。");
            setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'failed' } : img));
            return;
        }
    
        try {
            const imageWithoutPrefix = uploadedImage.split(',')[1];
            const modelInstruction = getModelInstruction(prompt, addText);
            
            const payload = {
                contents: [{
                    parts: [
                        { text: modelInstruction },
                        { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }
                    ]
                }],
            };
    
            const imageUrl = await generateImageWithRetry(payload);
    
            setGeneratedImages(prev => prev.map((img, index) =>
                index === imageIndex ? { ...img, status: 'success', imageUrl } : img
            ));
    
        } catch (err) {
            console.error(`為 ${prompt.id} 重新生成失敗:`, err);
            setError(`哎呀！為 "${prompt.id}" 重新生成失敗。請再試一次。`);
            setGeneratedImages(prev => prev.map((img, index) =>
                index === imageIndex ? { ...img, status: 'failed' } : img
            ));
        }
    };
    
    const handleImageUpload = async (event) => {
        const file = event.target.files[0];
        if (file) {
            setIsUploading(true);
            setError(null);
            try {
                const base64Image = await toBase64(file);
                setUploadedImage(base64Image);
                setGeneratedImages([]); 
                setSuggestedThemes([]); // 清除舊的建議
            } catch (err) {
                console.error("圖片上傳時發生錯誤:", err);
                setError("該圖片無法處理。請嘗試其他檔案。");
            } finally {
                setIsUploading(false);
            }
        }
    };
    
    const handleCaptureConfirm = (imageDataUrl) => {
        setUploadedImage(imageDataUrl);
        setGeneratedImages([]);
        setError(null);
        setSuggestedThemes([]); // 清除舊的建議
    };

    const handleGenerateClick = async () => {
        if (!uploadedImage) {
            setError("請先上傳一張照片！");
            return;
        }

        if (selectedStickers.length === 0) {
            setError("請至少選擇一個貼圖來生成！");
            return;
        }

        setIsLoading(true);
        setError(null);
        setGeneratedImages([]);
        
        setTimeout(() => {
            resultsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);

        const imageWithoutPrefix = uploadedImage.split(',')[1];
        const promptsForGeneration = activeStickerPack.filter(p => selectedStickers.includes(p.id));

        const initialPlaceholders = promptsForGeneration.map(p => ({
            id: p.id,
            memeText: p.memeText,
            status: 'pending',
            imageUrl: null,
        }));
        setGeneratedImages(initialPlaceholders);

        for (let i = 0; i < promptsForGeneration.length; i++) {
            const p = promptsForGeneration[i];
            try {
                const modelInstruction = getModelInstruction(p, addText);
                
                const payload = {
                    contents: [{
                        parts: [
                            { text: modelInstruction },
                            { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }
                        ]
                    }],
                };

                const imageUrl = await generateImageWithRetry(payload);

                setGeneratedImages(prev => prev.map((img, index) => 
                    index === i ? { ...img, status: 'success', imageUrl } : img
                ));

            } catch (err) {
                console.error(`為 ${p.id} 生成圖片在所有重試後失敗:`, err);
                setGeneratedImages(prev => prev.map((img, index) =>
                    index === i ? { ...img, status: 'failed' } : img
                ));
            }
        }

        setIsLoading(false);
    };

    const triggerDownload = (href, fileName) => {
        const link = document.createElement('a');
        link.href = href;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
    
    const handleDownloadRequest = (imageUrl, emotion, isProcessed = false) => {
        const suffix = isProcessed ? '-transparent' : '';
        const fileName = `sticker-${emotion.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`;
        triggerDownload(imageUrl, fileName);
    };

    const handleDownloadAllAsZip = async () => {
        if (isZipping || typeof window.JSZip === 'undefined') {
            if (typeof window.JSZip === 'undefined') {
                 setError("壓縮程式庫尚未載入，請稍後再試。");
            }
            return;
        }
        
        setIsZipping(true);
        setError(null);
        
        try {
            const zip = new window.JSZip();
            
            // 使用去背後的圖片（如果有的話），否則使用原始圖片
            const imagesToPack = processedImages.length > 0 ? processedImages : generatedImages.filter(img => img.status === 'success');

            if (imagesToPack.length === 0) {
                setError("沒有可以打包的貼圖。");
                return;
            }

            const imagePromises = imagesToPack.map(async (img) => {
                const imageUrl = img.processedImageUrl || img.imageUrl;
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                const suffix = img.isProcessed ? '-transparent' : '';
                const fileName = `sticker-${img.id.toLowerCase().replace(/\s+/g, '-')}${suffix}.png`;
                zip.file(fileName, blob);
            });

            await Promise.all(imagePromises);

            const content = await zip.generateAsync({ type: "blob" });
            
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = processedImages.length > 0 ? "ai-sticker-pack-transparent.zip" : "ai-sticker-pack.zip";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);

        } catch (err) {
            console.error("建立壓縮檔時發生錯誤:", err);
            setError("建立壓縮檔失敗，請再試一次。");
        } finally {
            setIsZipping(false);
        }
    };
    
    const handleStartOver = () => {
        setGeneratedImages([]);
        setUploadedImage(null);
        setError(null);
        setCustomStickerPack([]); // 清除客製化貼圖
        setCustomIdeaInput('');
        setSuggestedThemes([]);
        setSelectedStickers(defaultStickerPack.prompts.map(p => p.id)); // 重設為預設
        setProcessedImages([]); // 清除去背後的圖片
        setRemoveBgProgress(0); // 重設去背進度
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

    // 一鍵去背功能
    const handleRemoveBackground = async () => {
        const successfulImages = generatedImages.filter(img => img.status === 'success');
        
        if (successfulImages.length === 0) {
            setError("沒有可以處理的貼圖。");
            return;
        }

        setIsRemovingBackground(true);
        setRemoveBgProgress(0);
        setError(null);
        setProcessedImages([]);

        try {
            const processedResults = [];
            
            for (let i = 0; i < successfulImages.length; i++) {
                const img = successfulImages[i];
                try {
                    const processedImageUrl = await removeBackground(img.imageUrl);
                    processedResults.push({
                        ...img,
                        processedImageUrl,
                        isProcessed: true
                    });
                } catch (err) {
                    console.error(`去背失敗 ${img.id}:`, err);
                    processedResults.push({
                        ...img,
                        processedImageUrl: img.imageUrl, // 使用原始圖片
                        isProcessed: false
                    });
                }
                
                // 更新進度
                const progress = ((i + 1) / successfulImages.length) * 100;
                setRemoveBgProgress(progress);
                
                // 添加小延遲以顯示進度
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            setProcessedImages(processedResults);
            
        } catch (err) {
            console.error("去背處理失敗:", err);
            setError("去背處理失敗，請再試一次。");
        } finally {
            setIsRemovingBackground(false);
        }
    };

    // ✨ 新增：呼叫 Gemini 文字模型來生成貼圖點子
    const handleGenerateIdeas = async () => {
        if (!customIdeaInput.trim()) {
            setError("請輸入您的貼圖點子描述！");
            return;
        }
        setIsGeneratingIdeas(true);
        setError(null);
        setCustomStickerPack([]);
        setSuggestedThemes([]);

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const systemPrompt = `You are a creative assistant that generates fun and expressive chat sticker ideas. Based on the user's description, provide a list of 6 to 8 sticker ideas. Each idea MUST include:
1.  A short, descriptive \`id\` in Traditional Chinese (e.g., '喝咖啡', '打電動'). This will be the user-facing name.
2.  A detailed \`base\` prompt in English for an image generation model (e.g., 'happily sipping a large mug of coffee, looking energized').
3.  A short, catchy, English \`memeText\` (e.g., 'COFFEE!', 'GAME ON').

Your response MUST be a valid JSON array of objects, following this exact schema. Do not include any other text or markdown formatting.`;

        const payload = {
            contents: [{ parts: [{ text: customIdeaInput }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "id": { "type": "STRING" },
                            "base": { "type": "STRING" },
                            "memeText": { "type": "STRING" }
                        },
                        required: ["id", "base", "memeText"]
                    }
                }
            }
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API request failed with status ${response.status}`);
            }

            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (jsonText) {
                const ideas = JSON.parse(jsonText);
                setCustomStickerPack(ideas);
                setSelectedStickers(ideas.map(idea => idea.id)); // 自動全選新的點子
            } else {
                throw new Error("API did not return valid JSON content.");
            }
        } catch (err) {
            console.error("生成貼圖點子失敗:", err);
            setError("無法產生貼圖點子，請稍後再試。");
        } finally {
            setIsGeneratingIdeas(false);
        }
    };
    
    // ✨ 新增：從圖片取得主題建議（多模態）
    const handleGetInspirationFromImage = async () => {
        if (!uploadedImage) {
            setError("請先上傳一張照片才能取得靈感！");
            return;
        }
        setIsSuggestingThemes(true);
        setError(null);
        setSuggestedThemes([]);

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
        const imageWithoutPrefix = uploadedImage.split(',')[1];
        const textPrompt = `Analyze the person, their expression, clothing, and any notable objects or background in this image. Suggest 3 creative, short, and fun themes for a sticker pack based on what you see. For example, if you see a cat, suggest '貓奴日常'. If you see someone in a suit, suggest '辦公室風雲'. Return your answer as a simple JSON array of strings, like \`["主題一", "主題二", "主題三"]\`. Only return the JSON array.`;

        const payload = {
            contents: [{
                parts: [
                    { text: textPrompt },
                    { inlineData: { mimeType: "image/png", data: imageWithoutPrefix } }
                ]
            }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: { type: "ARRAY", items: { type: "STRING" } }
            }
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
             if (!response.ok) {
                throw new Error(`API request failed with status ${response.status}`);
            }

            const result = await response.json();
            const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (jsonText) {
                const themes = JSON.parse(jsonText);
                setSuggestedThemes(themes);
            } else {
                throw new Error("API did not return valid theme suggestions.");
            }
        } catch(err) {
            console.error("從圖片取得建議失敗:", err);
            setError("無法從圖片取得建議，請稍後再試。");
        } finally {
            setIsSuggestingThemes(false);
        }
    };


    const progress = generatedImages.length > 0
        ? (generatedImages.filter(img => img.status !== 'pending').length / generatedImages.length) * 100
        : 0;
    
    return (
        <>
            <style>{`
              @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&family=Inter:wght@400;500;600;700;900&display=swap');
              
              body { font-family: 'Inter', sans-serif; background-color: #000000; }
              .font-caveat { font-family: 'Caveat', cursive; }
              .bg-grid-pattern { background-image: linear-gradient(rgba(255,255,255,0.07) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.07) 1px, transparent 1px); background-size: 20px 20px; }
              
              @keyframes fade-in-down {
                0% { opacity: 0; transform: translateY(-20px) translateX(-50%); }
                100% { opacity: 1; transform: translateY(0) translateX(-50%); }
              }
              .animate-fade-in-down { animation: fade-in-down 0.5s ease-out forwards; }
              
              .custom-checkbox:checked {
                background-color: #FBBF24;
                border-color: #FBBF24;
              }
              .custom-checkbox:checked::after {
                opacity: 1;
              }
            `}</style>
            
            <CameraModal
                isOpen={isCameraOpen}
                onClose={() => setIsCameraOpen(false)}
                onCapture={handleCaptureConfirm}
            />

            <div className="bg-black text-gray-200 min-h-screen flex flex-col items-center p-4 pb-20">
                 <ErrorNotification message={error} onDismiss={() => setError(null)} />
                
                <div className="w-full max-w-6xl mx-auto">
                    
                    <header className="text-center my-12">
                        <h1 className="text-6xl md:text-7xl font-bold text-white tracking-tight">
                            One Click <span className="text-yellow-400">Sticker 2.0</span>
                        </h1>
                        <p className="mt-4 text-lg text-gray-500">將您的照片變成獨一無二的聊天貼圖。</p>
                    </header>

                    <main>
                        <div className="bg-gray-900/50 backdrop-blur-sm p-8 rounded-2xl shadow-2xl border border-gray-800 mb-16">
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-10">

                                <div>
                                    <h2 className="text-2xl font-semibold mb-6 text-white">1. 您的照片</h2>
                                    <div 
                                        className="w-full aspect-square border-4 border-dashed border-gray-700 rounded-xl flex items-center justify-center cursor-pointer hover:border-yellow-400 transition-colors bg-gray-800 overflow-hidden shadow-inner"
                                        onClick={() => !uploadedImage && fileInputRef.current && fileInputRef.current.click()}
                                    >
                                        {isUploading ? (
                                            <div className="flex flex-col items-center">
                                                <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-yellow-400"></div>
                                                <p className="text-gray-400 mt-4">上傳中...</p>
                                            </div>
                                        ) : uploadedImage ? (
                                            <img src={uploadedImage} alt="上傳預覽" className="w-full h-full object-cover" />
                                        ) : (
                                            <div className="flex flex-col items-center justify-center p-6 text-center text-gray-500">
                                                <IconUpload />
                                                <p className="mt-4 text-lg text-gray-300">點擊以上傳檔案</p>
                                                <p className="mt-4 text-sm">或</p>
                                                <Button
                                                    onClick={(e) => {
                                                        e.stopPropagation(); 
                                                        setIsCameraOpen(true);
                                                    }}
                                                    className="mt-2"
                                                >
                                                    <div className="flex items-center gap-2">
                                                        <IconCamera />
                                                        <span>使用相機</span>
                                                    </div>
                                                </Button>
                                            </div>
                                        )}
                                    </div>
                                    {uploadedImage && !isUploading && (
                                        <div className="flex flex-col sm:flex-row gap-4 mt-4 w-full">
                                            <Button onClick={() => fileInputRef.current && fileInputRef.current.click()} className="flex-1">
                                                更換檔案
                                            </Button>
                                            <Button onClick={() => setIsCameraOpen(true)} className="flex-1">
                                                <div className="flex items-center justify-center gap-2">
                                                    <IconCamera />
                                                    <span>使用相機</span>
                                                </div>
                                            </Button>
                                        </div>
                                    )}
                                     <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/png, image/jpeg" className="hidden" />
                                </div>

                                <div>
                                     <h2 className="text-2xl font-semibold mb-6 text-white">2. 選擇貼圖</h2>
                                     
                                     {/* ✨ Gemini LLM 功能區塊 */}
                                     <div className="bg-gray-800/50 p-4 rounded-lg border border-gray-700 mb-6">
                                        <h3 className="font-semibold text-lg mb-2 text-yellow-300">✨ AI 貼圖創意產生器</h3>
                                        <p className="text-gray-400 text-sm mb-3">描述一個主題，或讓 AI 從您的照片找靈感！</p>
                                        
                                        {/* ✨ 新增：從圖片取得靈感 */}
                                        <div className="mb-3">
                                            <Button onClick={handleGetInspirationFromImage} disabled={!uploadedImage || isSuggestingThemes} className="w-full">
                                                <div className="flex items-center justify-center gap-2">
                                                {isSuggestingThemes ? (
                                                    <>
                                                        <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-gray-300"></div>
                                                        <span>分析中...</span>
                                                    </>
                                                ) : (
                                                    <>
                                                        <IconSparkles />
                                                        <span>從圖片取得靈感</span>
                                                    </>
                                                )}
                                                </div>
                                            </Button>
                                            {suggestedThemes.length > 0 && (
                                                <div className="flex flex-wrap gap-2 mt-3">
                                                    {suggestedThemes.map(theme => (
                                                        <button 
                                                            key={theme} 
                                                            onClick={() => {
                                                                setCustomIdeaInput(theme);
                                                                handleGenerateIdeas();
                                                            }}
                                                            className="px-3 py-1 bg-gray-700 text-sm rounded-full hover:bg-gray-600"
                                                        >{theme}</button>
                                                    ))}
                                                </div>
                                            )}
                                        </div>

                                        <textarea 
                                            value={customIdeaInput}
                                            onChange={(e) => setCustomIdeaInput(e.target.value)}
                                            placeholder="例如：我家愛搗蛋的橘貓、辦公室專用..."
                                            className="w-full bg-gray-900 border border-gray-600 rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-yellow-400 text-white text-sm"
                                            rows="2"
                                        />
                                        <Button onClick={handleGenerateIdeas} disabled={isGeneratingIdeas} primary className="w-full mt-3">
                                            <div className="flex items-center justify-center gap-2">
                                                {isGeneratingIdeas ? (
                                                    <>
                                                        <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div>
                                                        <span>產生中...</span>
                                                    </>
                                                ) : (
                                                    "產生點子"
                                                )}
                                            </div>
                                        </Button>
                                     </div>

                                      <div className="flex justify-between items-center mb-4">
                                        <p className="text-gray-400">選擇您想生成的反應：</p>
                                        {customStickerPack.length > 0 && (
                                            <button 
                                                onClick={() => {
                                                    setCustomStickerPack([]);
                                                    setSelectedStickers(defaultStickerPack.prompts.map(p => p.id));
                                                }}
                                                className="text-xs text-yellow-400 hover:text-yellow-300"
                                            >
                                                ← 返回預設貼圖
                                            </button>
                                        )}
                                      </div>
                                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                                         {activeStickerPack.map(prompt => (
                                             <label key={prompt.id} className={`cursor-pointer p-3 rounded-lg border-2 text-center transition-colors duration-200 ${selectedStickers.includes(prompt.id) ? 'bg-yellow-400/20 border-yellow-400 text-white' : 'bg-gray-800 border-gray-700 hover:border-gray-600 text-gray-300'}`}>
                                                 <input
                                                     type="checkbox"
                                                     checked={selectedStickers.includes(prompt.id)}
                                                     onChange={() => handleStickerSelection(prompt.id)}
                                                     className="hidden"
                                                 />
                                                 <span className="font-semibold text-sm">{prompt.id}</span>
                                             </label>
                                         ))}
                                     </div>
                                      <div className="flex items-center space-x-6 mt-6">
                                        <div className="flex items-center">
                                            <input 
                                                type="checkbox" 
                                                id="addTextCheck"
                                                checked={addText}
                                                onChange={(e) => setAddText(e.target.checked)}
                                                className="custom-checkbox relative peer shrink-0 appearance-none w-5 h-5 border-2 border-gray-500 rounded-sm bg-gray-800 transition-colors after:absolute after:left-0 after:top-0 after:h-full after:w-full after:bg-no-repeat after:bg-center after:opacity-0 after:content-['✔'] after:text-black after:text-sm"
                                            />
                                            <label htmlFor="addTextCheck" className="ml-3 text-gray-300 cursor-pointer">加上文字</label>
                                        </div>
                                        <div className="flex items-center">
                                            <input 
                                                type="checkbox" 
                                                id="isDynamicCheck"
                                                checked={isDynamic}
                                                onChange={(e) => setIsDynamic(e.target.checked)}
                                                className="custom-checkbox relative peer shrink-0 appearance-none w-5 h-5 border-2 border-gray-500 rounded-sm bg-gray-800 transition-colors after:absolute after:left-0 after:top-0 after:h-full after:w-full after:bg-no-repeat after:bg-center after:opacity-0 after:content-['✔'] after:text-black after:text-sm"
                                            />
                                            <label htmlFor="isDynamicCheck" className="ml-3 text-gray-300 cursor-pointer">動態預覽</label>
                                        </div>
                                     </div>
                                </div>
                            </div>

                            <div className="mt-12 text-center">
                                <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                                    <Button
                                        onClick={handleGenerateClick}
                                        disabled={!uploadedImage || isLoading || isUploading}
                                        primary
                                        className="text-lg px-12 py-4"
                                    >
                                        <div className="flex items-center gap-3">
                                            {isLoading ? (
                                                <>
                                                    <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div>
                                                    {`生成中... (${Math.round(progress)}%)`}
                                                </>
                                            ) : (
                                                <>
                                                    <IconSparkles />
                                                    生成貼圖
                                                </>
                                            )}
                                        </div>
                                    </Button>
                                    
                                    {/* 一鍵去背按鈕 - 只在有成功生成的貼圖時顯示 */}
                                    {!isLoading && generatedImages.some(img => img.status === 'success') && (
                                        <div className="flex flex-col items-center gap-2">
                                            <Button
                                                onClick={handleRemoveBackground}
                                                disabled={isRemovingBackground}
                                                className="text-lg px-8 py-4 bg-green-600 hover:bg-green-500 text-white"
                                            >
                                                <div className="flex items-center gap-3">
                                                    {isRemovingBackground ? (
                                                        <>
                                                            <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-white"></div>
                                                            {`去背中... (${Math.round(removeBgProgress)}%)`}
                                                        </>
                                                    ) : (
                                                        <>
                                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                                                                <path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-3.876a1.5 1.5 0 0 0-4.471-4.471L9.53 16.122ZM21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                                                            </svg>
                                                            一鍵去背
                                                        </>
                                                    )}
                                                </div>
                                            </Button>
                                            <p className="text-xs text-gray-400 text-center max-w-xs">
                                                智能去除亮綠色背景，保留人物細節
                                            </p>
                                        </div>
                                    )}
                                </div>
                                
                                {/* 去背進度條 */}
                                {isRemovingBackground && (
                                    <div className="w-full max-w-md mx-auto mt-4">
                                        <div className="bg-gray-800 rounded-full h-3 overflow-hidden shadow-md">
                                            <motion.div
                                                className="bg-green-500 h-3 rounded-full"
                                                initial={{ width: 0 }}
                                                animate={{ width: `${removeBgProgress}%` }}
                                                transition={{ duration: 0.3 }}
                                            />
                                        </div>
                                                        <p className="text-gray-400 mt-2 text-sm">正在去除亮綠色背景，請稍候...</p>
                                    </div>
                                )}
                            </div>
                        </div>


                        <div ref={resultsRef}>
                            {(isLoading || generatedImages.length > 0) && (
                                <div className="mt-16">
                                    <h2 className="text-3xl font-bold text-white mb-8 text-center">您生成的貼圖</h2>

                                    {isLoading && (
                                        <div className="w-full max-w-4xl mx-auto mb-8 text-center">
                                            <div className="bg-gray-800 rounded-full h-3 overflow-hidden shadow-md">
                                                <motion.div
                                                    className="bg-yellow-400 h-3 rounded-full"
                                                    initial={{ width: 0 }}
                                                    animate={{ width: `${progress}%` }}
                                                    transition={{ duration: 0.5 }}
                                                />
                                            </div>
                                            <p className="text-gray-400 mt-4 text-sm">生成貼圖時請保持此視窗開啟。</p>
                                        </div>
                                    )}
                                     <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-6 mt-8">
                                        {generatedImages.map((img, index) => {
                                            switch (img.status) {
                                                case 'success':
                                                    // 檢查是否有去背後的版本
                                                    const processedImg = processedImages.find(p => p.id === img.id);
                                                    const displayImageUrl = processedImg ? processedImg.processedImageUrl : img.imageUrl;
                                                    const isProcessed = processedImg ? processedImg.isProcessed : false;
                                                    
                                                    return <StickerDisplay
                                                        key={`${img.id}-${index}-success`}
                                                        emotion={img.id}
                                                        imageUrl={displayImageUrl}
                                                        onDownload={(url, emotion) => handleDownloadRequest(url, emotion, isProcessed)}
                                                        onRegenerate={() => regenerateImageAtIndex(index)}
                                                        isDynamic={isDynamic}
                                                        isProcessed={isProcessed}
                                                    />;
                                                case 'failed':
                                                    return <ErrorCard
                                                        key={`${img.id}-${index}-failed`}
                                                        emotion={img.id}
                                                        onRegenerate={() => regenerateImageAtIndex(index)}
                                                    />;
                                                case 'pending':
                                                default:
                                                    return <LoadingCard 
                                                        key={`${img.id}-${index}-pending`} 
                                                        emotion={img.id} />;
                                            }
                                        })}
                                    </div>
                                </div>
                            )}

                            {!isLoading && generatedImages.length > 0 && (
                                <div className="text-center mt-16 mb-12 flex flex-col sm:flex-row items-center justify-center gap-6">
                                    <Button onClick={handleStartOver}>重新開始</Button>
                                    <Button onClick={handleDownloadAllAsZip} primary disabled={isZipping}>
                                        <div className="flex items-center gap-2">
                                        {isZipping ? (
                                            <>
                                               <div className="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-black"></div>
                                               <span>打包中...</span>
                                            </>
                                        ) : (
                                            <>
                                                <IconZip />
                                                <span>打包下載</span>
                                            </>
                                        )}
                                        </div>
                                    </Button>
                                </div>
                            )}
                        </div>
                    </main>
                    
                    {/* 底部連結按鈕區域 */}
                    <footer className="mt-20 mb-8">
                        <div className="text-center">
                            <h3 className="text-xl font-semibold text-gray-300 mb-6">更多精彩工具</h3>
                            <div className="flex flex-wrap justify-center gap-4">
                                <a
                                    href="https://www.youtube.com/watch?v=FXVu-1zmeKo"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-red-600 hover:bg-red-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" className="w-5 h-5">
                                        <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                                    </svg>
                                    一鍵換臉
                                </a>
                                
                                <a
                                    href="https://youtu.be/8M68FaiZ3I4?si=-5VXfob07bGVN_tL"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-purple-600 hover:bg-purple-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                                        <path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-3.876a1.5 1.5 0 0 0-4.471-4.471L9.53 16.122ZM21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                                    </svg>
                                    一鍵克隆風格
                                </a>
                                
                                <a
                                    href="https://novelpd.online/"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                                        <path strokeLinecap="round" strokeLinejoin="round" d="M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25" />
                                    </svg>
                                    AI小說生成
                                </a>
                                
                                <a
                                    href="https://www.facebook.com/profile.php?id=61556209555154"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" className="w-5 h-5">
                                        <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                                    </svg>
                                    原創-欣欣
                                </a>
                                
                                <a
                                    href="https://x.com/ririkaDDC"
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="px-6 py-3 bg-gray-800 hover:bg-gray-700 text-white rounded-lg font-semibold transition-colors duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" className="w-5 h-5">
                                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                                    </svg>
                                    Ririka X
                                </a>
                            </div>
                        </div>
                    </footer>
                </div>
            </div>
        </>
    );
};

export default App;

