<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1943 Battle of Midway - Final Version</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(180deg, #001122 0%, #003366 50%, #002244 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, 
                #87CEEB 0%,   /* Â§©Á©∫Ëóç */
                #4682B4 30%, /* ÈãºÈùíËóç */
                #1E90FF 70%, /* ÈÅìÂ•áËóç */
                #000080 100% /* Êµ∑ËªçËóç */
            );
            cursor: none;
            image-rendering: auto;
        }

        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #lives {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #FF6B6B;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #energy {
            position: absolute;
            top: 100px;
            left: 20px;
            color: #00BFFF;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #energyBar {
            position: absolute;
            top: 120px;
            left: 20px;
            width: 300px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00BFFF;
            border-radius: 6px;
        }

        #energyFill {
            height: 100%;
            background: linear-gradient(90deg, #00BFFF, #00FF7F, #32CD32);
            border-radius: 4px;
            transition: width 0.1s ease;
            box-shadow: 0 0 10px rgba(0, 255, 127, 0.5);
        }

        #superBombs {
            position: absolute;
            top: 140px;
            left: 20px;
            color: #00FF00;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #bossHealth {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #FFD700;
            border-radius: 15px;
            display: none;
        }

        #bossHealthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #FF0000 0%, #FF6B00 30%, #FFD700 100%);
            border-radius: 13px;
            transition: width 0.3s ease;
        }

        #bossHealthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFFFF;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #FFD700;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255, 215, 0, 0.5);
            border: 3px solid #FFD700;
            display: none;
            pointer-events: all;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #FFFFFF;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            opacity: 0.8;
        }

        #warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FF0000;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            animation: warningBlink 0.5s infinite alternate;
            display: none;
            text-align: center;
        }

        #gameTitle {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #FFFFFF;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            opacity: 0.9;
        }

        #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            z-index: 20;
            overflow: hidden;
        }

        #credits {
            position: absolute;
            bottom: -100%; /* Start off-screen */
            width: 100%;
            font-size: 32px;
            line-height: 1.5;
            animation: scrollCredits 15s linear forwards;
        }

        @keyframes scrollCredits {
            0% { bottom: -50%; }
            100% { bottom: 150%; }
        }

        @keyframes warningBlink {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="gameUI">
        <div id="score">ÂàÜÊï∏: 0</div>
        <div id="lives">ÁîüÂëΩ: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="energy">ËÉΩÊ∫ê: 200%</div>
        <div id="energyBar">
            <div id="energyFill" style="width: 100%"></div>
        </div>
        <div id="superBombs">Ë∂ÖÁ¥öÁÇ∏ÂΩà: üí£üí£üí£</div>
        
        <div id="bossHealth">
            <div id="bossHealthBar"></div>
            <div id="bossHealthText"></div>
        </div>
        
        <div id="warning"></div>
        
        <div id="gameTitle">1943 ‰∏≠ÈÄîÂ≥∂Êà∞ÂΩπ</div>

        <div id="controls">
            WASD/ÊñπÂêëÈçµ: ÁßªÂãï | Á©∫ÁôΩÈçµ: ÈÄ£ÁôºÂ∞ÑÊìä | BÈçµ: Ë∂ÖÁ¥öÁÇ∏ÂΩà | R: ÈáçÊñ∞ÈñãÂßã
        </div>
        
        <div id="gameOver">
            <div>ÈÅäÊà≤ÁµêÊùü</div>
            <div style="font-size: 18px; margin-top: 20px;">Êåâ R ÈçµÈáçÊñ∞ÈñãÂßã</div>
        </div>

        <div id="victoryScreen">
            <div id="credits">
                <h1>VICTORY</h1>
                <br><br>
                <p>ÊÑüË¨ù</p>
                <p>ECFÂúòÈöäÂâµ‰Ωú</p>
                <br><br>
                <p>Êåâ R ÈçµÈáçÊñ∞ÈñãÂßã</p>
            </div>
        </div>
    </div>

    <script>
        // ÈÅäÊà≤ÂàùÂßãÂåñ
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const warningElement = document.getElementById('warning');
        
        // Ë®≠ÂÆöÁï´Â∏ÉÂ§ßÂ∞è
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // --- Èü≥ÊïàÁÆ°ÁêÜ (ÈåØË™§‰øÆÊ≠£Áâà) ---
        const audioManager = {
            isInitialized: false,
            mainVolume: null,
            playerShoot: null,
            explosion: null,
            playerHit: null,
            enemyShoot: null,
            superBomb: null,
            warning: null,
            victory: null,
            music: null,

            async init() {
                if (this.isInitialized) return;
                try {
                    await Tone.start();
                    console.log("Audio context started successfully.");
                    this.mainVolume = new Tone.Volume(-25).toDestination();

                    this.playerShoot = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'square4' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).connect(this.mainVolume);
                    this.playerShoot.volume.value = -12;
                    this.explosion = new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 } }).connect(this.mainVolume);
                    this.explosion.volume.value = -4;
                    this.playerHit = new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 5, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.01, release: 0.5 } }).connect(this.mainVolume);
                    this.playerHit.volume.value = 0;
                    this.enemyShoot = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.02, release: 0.2 } }).connect(this.mainVolume);
                    this.enemyShoot.volume.value = -16;
                    this.superBomb = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 1.5, sustain: 0, release: 1 } }).connect(this.mainVolume);
                    this.superBomb.volume.value = +3;
                    this.warning = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.2, decay: 0.5, sustain: 0.3, release: 1 } }).connect(this.mainVolume);
                    this.warning.volume.value = -2;
                    this.victory = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fatsawtooth' }, envelope: { attack: 0.1, decay: 0.8, sustain: 0.2, release: 1 } }).connect(this.mainVolume);
                    this.victory.volume.value = -5;
                    const musicSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "pulse", width: 0.3 }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).connect(this.mainVolume);
                    this.music = new Tone.Sequence((time, note) => { musicSynth.triggerAttackRelease(note, "8n", time); }, ['C2', ['E2', 'G2'], 'B2', ['G2', 'C3']], "4n").start(0);
                    
                    Tone.Transport.bpm.value = 130;
                    Tone.Transport.start();
                    
                    this.isInitialized = true;
                } catch (e) {
                    console.error("Could not start audio context: ", e);
                }
            },
            play(sound) {
                if (!this.isInitialized || !this[sound]) return;
                
                const now = Tone.now();
                switch(sound) {
                    case 'playerShoot': this.playerShoot.triggerAttackRelease('G5', '16n', now); break;
                    case 'explosion': this.explosion.triggerAttackRelease('8n', now); break;
                    case 'playerHit': this.playerHit.triggerAttackRelease('C2', '8n', now); break;
                    case 'enemyShoot': this.enemyShoot.triggerAttackRelease('C4', '16n', now); break;
                    case 'superBomb': this.superBomb.triggerAttackRelease('2n', now); break;
                    case 'warning': 
                        this.warning.triggerAttackRelease('A4', '0.5n', now);
                        this.warning.triggerAttackRelease('A4', '0.5n', now + 0.7);
                        break;
                    case 'victory':
                        this.victory.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '1n', now);
                        break;
                }
            },
            controlMusic(shouldPlay) {
                if (!this.isInitialized) return;
                if (shouldPlay) {
                    this.mainVolume.volume.rampTo(-25, 1);
                } else {
                    this.mainVolume.volume.rampTo(-Infinity, 1);
                }
            }
        };

        // ÈÅäÊà≤ÁãÄÊÖã
        let gameState = {
            score: 0, lives: 5, energy: 200, maxEnergy: 200, superBombs: 3,
            isGameOver: false, keys: {}, gameTime: 0, 
            bossPhase: 'none', // none, starting_escort1, escort1, starting_escort2, escort2, starting_yamato, yamato, victory
            shootCooldown: 0
        };

        // Áé©ÂÆ∂Êà∞Ê©ü
        const player = { x: canvas.width / 2, y: canvas.height - 100, width: 55, height: 75, speed: 6, invulnerable: 0 };

        // Â§ßÂíåÊà∞Ëâ¶ (ÁÅ´ÂäõÂ¢ûÂº∑)
        const yamato = {
            name: "Â§ßÂíåËôüÊà∞Ëâ¶",
            x: canvas.width / 2, y: 150, baseY: 150, width: 400, height: 100, health: 500, maxHealth: 500, speed: 0.5, direction: 1,
            turrets: [
                { x: -120, y: 10, angle: 0, shootTimer: 0, size: 25, shootInterval: 200 }, { x: -80, y: -15, angle: 0, shootTimer: 60, size: 25, shootInterval: 200 },
                { x: 150, y: 0, angle: 0, shootTimer: 120, size: 25, shootInterval: 200 }, { x: -160, y: -20, angle: 0, shootTimer: 30, size: 15, shootInterval: 150 },
                { x: -160, y: 20, angle: 0, shootTimer: 90, size: 15, shootInterval: 150 }, { x: 50, y: -25, angle: 0, shootTimer: 60, size: 15, shootInterval: 150 },
                { x: 50, y: 25, angle: 0, shootTimer: 120, size: 15, shootInterval: 150 }, { x: -20, y: -35, angle: 0, shootTimer: 15, size: 10, shootInterval: 100 },
                { x: -20, y: 35, angle: 0, shootTimer: 45, size: 10, shootInterval: 100 }, { x: 100, y: -30, angle: 0, shootTimer: 75, size: 10, shootInterval: 100 },
                { x: 100, y: 30, angle: 0, shootTimer: 105, size: 10, shootInterval: 100 }
            ]
        };

        // ÈÅäÊà≤Áâ©‰ª∂Èô£Âàó
        let bullets = [];
        let enemyBullets = [];
        let enemies = [];
        let explosions = [];
        let clouds = [];
        let superBombExplosions = [];
        let escortShips = [];
        let islands = [];
        let friendlyShips = [];
        let mistParticles = [];
        let confetti = [];

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            if (player.invulnerable > 0) { ctx.globalAlpha = Math.sin(player.invulnerable * 0.5) * 0.5 + 0.5; }
            const fuselageGradient = ctx.createLinearGradient(-player.width/2, 0, player.width/2, 0);
            fuselageGradient.addColorStop(0, '#2F4F2F');
            fuselageGradient.addColorStop(0.3, '#6B8E23');
            fuselageGradient.addColorStop(0.7, '#556B2F');
            fuselageGradient.addColorStop(1, '#2F4F2F');
            ctx.fillStyle = fuselageGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, player.width/2, player.height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            const wingGradient = ctx.createLinearGradient(-30, 0, 30, 0);
            wingGradient.addColorStop(0, '#4F4F4F');
            wingGradient.addColorStop(0.5, '#6B8E23');
            wingGradient.addColorStop(1, '#4F4F4F');
            ctx.fillStyle = wingGradient;
            ctx.beginPath();
            ctx.moveTo(-player.width/2 - 20, -8);
            ctx.lineTo(-player.width/2 - 35, 5);
            ctx.lineTo(-player.width/2 - 20, 35);
            ctx.lineTo(-player.width/2 + 5, 25);
            ctx.lineTo(-player.width/2, 5);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(player.width/2 + 20, -8);
            ctx.lineTo(player.width/2 + 35, 5);
            ctx.lineTo(player.width/2 + 20, 35);
            ctx.lineTo(player.width/2 - 5, 25);
            ctx.lineTo(player.width/2, 5);
            ctx.closePath();
            ctx.fill();
            const cockpitGradient = ctx.createRadialGradient(0, -15, 0, 0, -15, 15);
            cockpitGradient.addColorStop(0, 'rgba(0,50,100,0.8)');
            cockpitGradient.addColorStop(1, 'rgba(0,25,50,0.9)');
            ctx.fillStyle = cockpitGradient;
            ctx.fillRect(-12, -28, 24, 30);
            ctx.save();
            ctx.translate(-player.width/2 - 15, 15);
            ctx.scale(0.6, 0.6);
            drawUSAirForceStar();
            ctx.restore();
            ctx.save();
            ctx.translate(player.width/2 + 15, 15);
            ctx.scale(0.6, 0.6);
            drawUSAirForceStar();
            ctx.restore();
            ctx.fillStyle = '#2F2F2F';
            ctx.fillRect(-6, -player.height/2, 4, 25);
            ctx.fillRect(-2, -player.height/2, 4, 25);
            ctx.fillRect(2, -player.height/2, 4, 25);
            ctx.save();
            ctx.translate(0, -player.height/2 - 5);
            ctx.rotate(gameState.gameTime * 0.8);
            ctx.fillStyle = 'rgba(100,100,100,0.7)';
            ctx.fillRect(-1, -15, 2, 30);
            ctx.fillRect(-15, -1, 30, 2);
            ctx.restore();
            const exhaustGradient = ctx.createLinearGradient(0, player.height/2, 0, player.height/2 + 25);
            exhaustGradient.addColorStop(0, 'rgba(255,100,0,0.8)');
            exhaustGradient.addColorStop(0.5, 'rgba(255,200,0,0.6)');
            exhaustGradient.addColorStop(1, 'rgba(255,100,0,0)');
            ctx.fillStyle = exhaustGradient;
            ctx.fillRect(-8, player.height/2, 16, 25);
            ctx.restore();
        }

        function drawUSAirForceStar() {
            ctx.fillStyle = '#002868';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                const x = Math.cos(angle) * 8;
                const y = Math.sin(angle) * 8;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                const innerAngle = ((i + 0.5) * Math.PI * 2 / 5) - Math.PI / 2;
                const innerX = Math.cos(innerAngle) * 4;
                const innerY = Math.sin(innerAngle) * 4;
                ctx.lineTo(innerX, innerY);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawJapaneseZero(enemy) {
            ctx.save();
            ctx.translate(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
            ctx.rotate(Math.PI);
            const fuselageGradient = ctx.createLinearGradient(-enemy.width/2, 0, enemy.width/2, 0);
            fuselageGradient.addColorStop(0, '#1B4B3B');
            fuselageGradient.addColorStop(0.3, '#2E7D32');
            fuselageGradient.addColorStop(0.7, '#388E3C');
            fuselageGradient.addColorStop(1, '#1B4B3B');
            ctx.fillStyle = fuselageGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, enemy.width/2, enemy.height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            const wingGradient = ctx.createLinearGradient(-25, 0, 25, 0);
            wingGradient.addColorStop(0, '#2E7D32');
            wingGradient.addColorStop(0.5, '#4CAF50');
            wingGradient.addColorStop(1, '#2E7D32');
            ctx.fillStyle = wingGradient;
            ctx.beginPath();
            ctx.ellipse(-enemy.width/2 - 12, 0, 15, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(enemy.width/2 + 12, 0, 15, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.save();
            ctx.translate(-enemy.width/2 - 12, 0);
            ctx.scale(0.5, 0.5);
            drawRisingSun();
            ctx.restore();
            ctx.save();
            ctx.translate(enemy.width/2 + 12, 0);
            ctx.scale(0.5, 0.5);
            drawRisingSun();
            ctx.restore();
            ctx.fillStyle = 'rgba(50,50,50,0.8)';
            ctx.fillRect(-8, -15, 16, 20);
            ctx.fillStyle = '#333333';
            ctx.fillRect(-4, -enemy.height/2, 3, 20);
            ctx.fillRect(1, -enemy.height/2, 3, 20);
            ctx.save();
            ctx.translate(0, -enemy.height/2 - 3);
            ctx.rotate(gameState.gameTime * 0.6);
            ctx.fillStyle = 'rgba(80,80,80,0.6)';
            ctx.fillRect(-1, -12, 2, 24);
            ctx.fillRect(-12, -1, 24, 2);
            ctx.restore();
            ctx.restore();
            if (enemy.health < enemy.maxHealth) {
                const barWidth = enemy.width;
                const barHeight = 4;
                ctx.fillStyle = 'rgba(255,0,0,0.8)';
                ctx.fillRect(enemy.x, enemy.y - 10, barWidth, barHeight);
                ctx.fillStyle = 'rgba(0,255,0,0.8)';
                ctx.fillRect(enemy.x, enemy.y - 10, (barWidth * enemy.health / enemy.maxHealth), barHeight);
            }
        }

        function drawRisingSun() {
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#DC143C';
            ctx.beginPath();
            ctx.arc(0, 0, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEscortShip(ship) {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.shadowColor = 'rgba(0,0,0,0.4)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            const shipGradient = ctx.createLinearGradient(0, -ship.height / 2, 0, ship.height / 2);
            shipGradient.addColorStop(0, '#505050');
            shipGradient.addColorStop(0.5, '#707070');
            shipGradient.addColorStop(1, '#505050');
            ctx.fillStyle = shipGradient;
            ctx.beginPath();
            ctx.moveTo(-ship.width / 2, 0);
            ctx.lineTo(-ship.width / 2 + 20, -ship.height / 2);
            ctx.lineTo(ship.width / 2 - 20, -ship.height / 2);
            ctx.lineTo(ship.width / 2, 0);
            ctx.lineTo(ship.width / 2 - 20, ship.height / 2);
            ctx.lineTo(-ship.width / 2 + 20, ship.height / 2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#303030';
            ctx.stroke();
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#606060';
            ctx.fillRect(-15, -ship.height/2 - 15, 30, 15);
            ship.turrets.forEach(turret => {
                ctx.save();
                ctx.translate(turret.x, turret.y);
                ctx.rotate(turret.angle);
                ctx.fillStyle = '#4A4A4A';
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#3A3A3A';
                ctx.fillRect(-3, -20, 6, 20);
                ctx.restore();
            });
            ctx.restore();
        }
        
        function drawYamato() {
            if (gameState.bossPhase !== 'yamato') return;
            ctx.save();
            ctx.translate(yamato.x, yamato.y);
            const wakeX = -yamato.width / 2;
            const wakeY = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(wakeX, wakeY);
            ctx.quadraticCurveTo(wakeX + 20, wakeY - 30, wakeX + 60, wakeY - 10);
            ctx.quadraticCurveTo(wakeX + 100, wakeY + 10, wakeX + 60, wakeY + 20);
            ctx.quadraticCurveTo(wakeX + 20, wakeY + 40, wakeX, wakeY);
            ctx.fill();
            const wakeX2 = yamato.width / 2;
            ctx.beginPath();
            ctx.moveTo(wakeX2, wakeY);
            ctx.quadraticCurveTo(wakeX2 - 20, wakeY - 30, wakeX2 - 60, wakeY - 10);
            ctx.quadraticCurveTo(wakeX2 - 100, wakeY + 10, wakeX2 - 60, wakeY + 20);
            ctx.quadraticCurveTo(wakeX2 - 20, wakeY + 40, wakeX2, wakeY);
            ctx.fill();
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 10;
            ctx.shadowOffsetY = 10;
            const shipGradient = ctx.createLinearGradient(0, -yamato.height / 2, 0, yamato.height / 2);
            shipGradient.addColorStop(0, '#696969');
            shipGradient.addColorStop(0.5, '#808080');
            shipGradient.addColorStop(1, '#696969');
            ctx.fillStyle = shipGradient;
            ctx.beginPath();
            ctx.moveTo(-yamato.width / 2, 0);
            ctx.quadraticCurveTo(-yamato.width/2 + 50, -yamato.height/2, -yamato.width/2 + 150, -yamato.height/2 + 10);
            ctx.lineTo(yamato.width / 2 - 50, -yamato.height/2 + 10);
            ctx.quadraticCurveTo(yamato.width / 2, -yamato.height/2, yamato.width / 2, 0);
            ctx.quadraticCurveTo(yamato.width / 2, yamato.height/2, yamato.width / 2 - 50, yamato.height/2 - 10);
            ctx.lineTo(-yamato.width / 2 + 150, yamato.height/2 - 10);
            ctx.quadraticCurveTo(-yamato.width/2 + 50, yamato.height/2, -yamato.width / 2, 0);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#404040';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowColor = 'transparent';
            const deckGradient = ctx.createLinearGradient(-yamato.width / 2, 0, yamato.width / 2, 0);
            deckGradient.addColorStop(0, '#A0522D');
            deckGradient.addColorStop(0.5, '#D2B48C');
            deckGradient.addColorStop(1, '#A0522D');
            ctx.fillStyle = deckGradient;
            ctx.beginPath();
            ctx.moveTo(-yamato.width / 2 + 120, -15);
            ctx.lineTo(yamato.width / 2 - 20, -30);
            ctx.lineTo(yamato.width / 2 - 20, 30);
            ctx.lineTo(-yamato.width / 2 + 120, 15);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#606060';
            ctx.fillRect(-30, -35, 60, 30);
            ctx.fillStyle = '#707070';
            ctx.fillRect(-25, -55, 50, 20);
            ctx.fillStyle = '#808080';
            ctx.fillRect(-15, -70, 30, 15);
            ctx.strokeStyle = '#A9A9A9';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -70);
            ctx.lineTo(0, -85);
            ctx.moveTo(-10, -85);
            ctx.lineTo(10, -85);
            ctx.stroke();
            ctx.save();
            ctx.translate(25, -65);
            ctx.scale(0.7, 0.7);
            drawRisingSun();
            ctx.restore();
            yamato.turrets.forEach(turret => {
                ctx.save();
                ctx.translate(turret.x, turret.y);
                ctx.rotate(turret.angle);
                const turretGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, turret.size);
                turretGradient.addColorStop(0, '#A9A9A9');
                turretGradient.addColorStop(0.7, '#696969');
                turretGradient.addColorStop(1, '#505050');
                ctx.fillStyle = turretGradient;
                ctx.beginPath();
                ctx.arc(0, 0, turret.size * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = '#5A5A5A';
                const barrelLength = turret.size * 1.5;
                const barrelWidth = turret.size * 0.3;
                ctx.fillRect(-barrelWidth / 2, -barrelLength, barrelWidth, barrelLength);
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(-barrelWidth/2 - 1, -barrelLength - 4, barrelWidth + 2, 4);
                ctx.restore();
            });
            ctx.fillStyle = '#5A5A5A';
            ctx.fillRect(80, -20, 20, 40);
            ctx.fillStyle = '#3A3A3A';
            ctx.fillRect(80, -25, 20, 5);
            ctx.fillStyle = `rgba(200, 200, 200, ${0.2 + Math.random() * 0.2})`;
            ctx.beginPath();
            ctx.ellipse(90, -45 - Math.random() * 20, 10, 20 + Math.random() * 10, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawIsland(island) {
            ctx.save();
            ctx.translate(island.x, island.y);
            ctx.fillStyle = '#8B5A2B';
            ctx.beginPath();
            ctx.moveTo(island.points[0].x, island.points[0].y);
            for (let i = 1; i < island.points.length; i++) {
                ctx.lineTo(island.points[i].x, island.points[i].y);
            }
            ctx.closePath();
            ctx.fill();
            if (island.hasGreenery) {
                ctx.fillStyle = '#2E8B57';
                ctx.beginPath();
                ctx.arc(0, 0, island.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawFriendlyShip(ship) {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 5;

            const hullGradient = ctx.createLinearGradient(0, -ship.height / 2, 0, ship.height / 2);
            hullGradient.addColorStop(0, '#BDBDBD');
            hullGradient.addColorStop(1, '#757575');
            ctx.fillStyle = hullGradient;

            ctx.beginPath();
            ctx.moveTo(-ship.width / 2, 0);
            ctx.lineTo(-ship.width / 2 + 20, -ship.height / 2);
            ctx.lineTo(ship.width / 2 - 10, -ship.height / 2);
            ctx.lineTo(ship.width / 2, 0);
            ctx.lineTo(ship.width / 2 - 10, ship.height / 2);
            ctx.lineTo(-ship.width / 2 + 20, ship.height / 2);
            ctx.closePath();
            ctx.fill();

            ctx.shadowColor = 'transparent';

            ctx.fillStyle = '#9E9E9E';
            ctx.fillRect(-20, -ship.height / 2 - 15, 30, 15);
            ctx.fillStyle = '#E0E0E0';
            ctx.fillRect(-15, -ship.height / 2 - 25, 20, 10);

            ctx.fillStyle = '#616161';
            ctx.fillRect(25, -ship.height / 2 - 20, 12, 20);
            ctx.fillStyle = '#424242';
            ctx.fillRect(25, -ship.height / 2 - 23, 12, 3);

            if (ship.width > 140) {
                ctx.fillStyle = '#757575';
                ctx.fillRect(50, -ship.height/2 + 5, 30, ship.height - 10);
                ctx.fillRect(90, -ship.height/2 + 5, 30, ship.height - 10);
            }
            ctx.restore();
        }

        function drawMist() {
            mistParticles.forEach(p => {
                ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawVictory() {
            confetti.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 2);
                ctx.restore();
            });
        }

        function createBullet(x, y, isSuper = false) {
            if (!isSuper && gameState.energy < 3) return;
            if (!isSuper) gameState.energy -= 3;
            audioManager.play('playerShoot');
            bullets.push({ x, y, width: isSuper ? 8 : 4, height: isSuper ? 20 : 12, speed: isSuper ? 12 : 10, damage: isSuper ? 8 : 2, color: isSuper ? '#00FF00' : '#FFD700', isSuper });
        }

        function createEnemyBullet(x, y, targetX, targetY) {
            const dx = targetX - x;
            const dy = targetY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            audioManager.play('enemyShoot');
            enemyBullets.push({ x, y, vx: (dx / distance) * 3, vy: (dy / distance) * 3, width: 6, height: 15, color: '#FF4500' });
        }

        function createSuperBombExplosion() {
            if (gameState.superBombs <= 0) return;
            gameState.superBombs--;
            audioManager.play('superBomb');
            superBombExplosions.push({ x: player.x, y: player.y, radius: 0, maxRadius: 450, life: 80, damage: 60 });
            enemies = [];
            enemyBullets = [];
        }

        function createEnemy() {
            let spawnRate = 0.015;
            if (gameState.bossPhase === 'escort1' || gameState.bossPhase === 'escort2') {
                spawnRate = 0.04;
            } else if (gameState.bossPhase === 'yamato') {
                spawnRate = 0.053;
            }
            if (Math.random() > spawnRate) return;

            const enemyTypes = [
                { width: 35, height: 45, speed: 2, points: 150, health: 2, type: 'zero' },
                { width: 32, height: 42, speed: 2.5, points: 200, health: 3, type: 'zero' },
                { width: 38, height: 48, speed: 1.5, points: 250, health: 4, type: 'zero' }
            ];
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            enemies.push({ x: Math.random() * (canvas.width - type.width), y: -type.height, ...type, maxHealth: type.health, shootTimer: 0 });
        }

        function createEscortShip(x, y, name) {
            escortShips.push({ 
                name: name,
                x, y, width: 200, height: 50, health: 100, maxHealth: 100, speed: 0.8, direction: x > canvas.width / 2 ? -1 : 1,
                turrets: [
                    { x: -70, y: -10, angle: 0, shootTimer: 0, shootInterval: 180 }, { x: -40, y: 10, angle: 0, shootTimer: 45, shootInterval: 180 },
                    { x: 40, y: -10, angle: 0, shootTimer: 90, shootInterval: 180 }, { x: 70, y: 10, angle: 0, shootTimer: 135, shootInterval: 180 }
                ]
            });
        }

        function createExplosion(x, y, size = 1) {
            audioManager.play('explosion');
            explosions.push({ x, y, particles: [], life: 50 * size });
            const particleCount = 25 * size;
            for (let i = 0; i < particleCount; i++) {
                explosions[explosions.length - 1].particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 18 * size,
                    vy: (Math.random() - 0.5) * 18 * size,
                    color: ['#FFD700', '#FF4500', '#FF6B6B'][Math.floor(Math.random() * 3)],
                    size: (2 + Math.random() * 8) * size
                });
            }
        }

        function createCloud() {
            clouds.push({ x: Math.random() * canvas.width, y: -100, width: 60 + Math.random() * 50, height: 30 + Math.random() * 25, speed: 0.5 + Math.random() * 0.5, opacity: 0.15 + Math.random() * 0.25 });
        }

        function createIsland() {
            const size = 40 + Math.random() * 80;
            const points = [];
            const pointCount = 5 + Math.floor(Math.random() * 5);
            for (let i = 0; i < pointCount; i++) {
                const angle = (i / pointCount) * Math.PI * 2;
                const radius = size * (0.7 + Math.random() * 0.3);
                points.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
            }
            islands.push({ x: Math.random() * canvas.width, y: -size, size: size, speed: 1, points: points, hasGreenery: Math.random() > 0.4 });
        }

        function createFriendlyShip() {
            const isTransport = Math.random() > 0.5;
            friendlyShips.push({
                x: Math.random() * canvas.width, y: -150,
                width: isTransport ? 150 : 120,
                height: isTransport ? 40 : 25,
                speed: 1 + Math.random() * 0.5
            });
        }

        function createMist() {
            mistParticles.push({
                x: Math.random() * canvas.width, y: -50,
                radius: 50 + Math.random() * 100,
                speed: 0.2 + Math.random() * 0.3,
                opacity: 0.05 + Math.random() * 0.1
            });
        }

        function createConfettiBurst() {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800'];
            for (let i = 0; i < 200; i++) {
                confetti.push({
                    x: Math.random() * canvas.width,
                    y: -Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 5,
                    vy: 2 + Math.random() * 3,
                    size: 5 + Math.random() * 5,
                    angle: Math.random() * Math.PI * 2,
                    rotation: (Math.random() - 0.5) * 0.2,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
        }

        function showWarning(text, duration = 3000) {
            audioManager.play('warning');
            warningElement.innerHTML = text;
            warningElement.style.display = 'block';
            setTimeout(() => {
                warningElement.style.display = 'none';
            }, duration);
        }

        function updateBossHealthBar(boss) {
            const healthBar = document.getElementById('bossHealth');
            if (boss && boss.health > 0) {
                healthBar.style.display = 'block';
                document.getElementById('bossHealthText').textContent = boss.name;
                const healthPercent = Math.max(0, (boss.health / boss.maxHealth) * 100);
                document.getElementById('bossHealthBar').style.width = healthPercent + '%';
            } else {
                healthBar.style.display = 'none';
            }
        }

        function update() {
            if (gameState.isGameOver && gameState.bossPhase !== 'victory') {
                if (audioManager.isInitialized) audioManager.controlMusic(false);
                return;
            }
            
            gameState.gameTime++;
            
            if (gameState.bossPhase === 'victory') {
                confetti.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.angle += p.rotation;
                    p.vy += 0.05; // gravity
                });
                return;
            }

            if (gameState.energy < gameState.maxEnergy) {
                gameState.energy += 0.5;
                if (gameState.energy > gameState.maxEnergy) {
                    gameState.energy = gameState.maxEnergy;
                }
            }

            if (gameState.shootCooldown > 0) {
                gameState.shootCooldown--;
            }

            // Boss Phase Logic
            if (gameState.bossPhase === 'none' && gameState.gameTime > 1500) {
                gameState.bossPhase = 'starting_escort1';
                showWarning('‚ö†Ô∏è Á¨¨‰∏ÄË≠∑Ë°õËâ¶Èöä: Èï∑ÂíåËâ¶ÔºÅ ‚ö†Ô∏è');
                setTimeout(() => {
                    gameState.bossPhase = 'escort1';
                    createEscortShip(canvas.width / 2, 120, 'Èï∑ÂíåËâ¶');
                }, 3000);
            } else if (gameState.bossPhase === 'escort1' && escortShips.length === 0) {
                gameState.bossPhase = 'starting_escort2';
                showWarning('‚ö†Ô∏è Á¨¨‰∫åË≠∑Ë°õËâ¶Èöä: Â±±ÂüéËâ¶ÔºÅ ‚ö†Ô∏è');
                setTimeout(() => {
                    gameState.bossPhase = 'escort2';
                    createEscortShip(canvas.width / 2, 120, 'Â±±ÂüéËâ¶');
                }, 3000);
            } else if (gameState.bossPhase === 'escort2' && escortShips.length === 0) {
                gameState.bossPhase = 'starting_yamato';
                showWarning('‚ö†Ô∏è ÊóóËâ¶„ÄåÂ§ßÂíå„ÄçËôüÂá∫ÁèæÔºÅ ‚ö†Ô∏è');
                setTimeout(() => {
                    gameState.bossPhase = 'yamato';
                }, 3000);
            }

            if (player.invulnerable > 0) {
                player.invulnerable--;
            }

            if (gameState.keys['ArrowLeft'] || gameState.keys['a'] || gameState.keys['A']) { player.x = Math.max(player.width/2, player.x - player.speed); }
            if (gameState.keys['ArrowRight'] || gameState.keys['d'] || gameState.keys['D']) { player.x = Math.min(canvas.width - player.width/2, player.x + player.speed); }
            if (gameState.keys['ArrowUp'] || gameState.keys['w'] || gameState.keys['W']) { player.y = Math.max(player.height/2, player.y - player.speed); }
            if (gameState.keys['ArrowDown'] || gameState.keys['s'] || gameState.keys['S']) { player.y = Math.min(canvas.height - player.height/2, player.y + player.speed); }

            if (gameState.keys[' '] && gameState.shootCooldown <= 0 && gameState.energy >= 3) {
                createBullet(player.x - 8, player.y - player.height/2);
                createBullet(player.x + 8, player.y - player.height/2);
                gameState.shootCooldown = 2;
            }

            // Update Bosses and Health Bar
            let currentBoss = null;
            if (gameState.bossPhase === 'escort1' || gameState.bossPhase === 'escort2') {
                currentBoss = escortShips[0];
            } else if (gameState.bossPhase === 'yamato') {
                currentBoss = yamato;
            }
            updateBossHealthBar(currentBoss);


            escortShips.forEach(ship => {
                ship.x += ship.speed * ship.direction;
                if (ship.x < ship.width / 2 || ship.x > canvas.width - ship.width / 2) { ship.direction *= -1; }
                ship.turrets.forEach(turret => {
                    const turretWorldX = ship.x + turret.x;
                    const turretWorldY = ship.y + turret.y;
                    const dx = player.x - turretWorldX;
                    const dy = player.y - turretWorldY;
                    turret.angle = Math.atan2(dy, dx) - Math.PI / 2;
                    turret.shootTimer++;
                    if (turret.shootTimer > turret.shootInterval) {
                        createEnemyBullet(turretWorldX, turretWorldY, player.x, player.y);
                        turret.shootTimer = 0;
                    }
                });
            });

            if (gameState.bossPhase === 'yamato') {
                yamato.x += yamato.speed * yamato.direction;
                if (yamato.x <= yamato.width / 2 || yamato.x >= canvas.width - yamato.width / 2) { yamato.direction *= -1; }
                yamato.y = yamato.baseY + Math.sin(gameState.gameTime * 0.03) * 8;
                yamato.turrets.forEach(turret => {
                    const turretWorldX = yamato.x + turret.x;
                    const turretWorldY = yamato.y + turret.y;
                    const dx = player.x - turretWorldX;
                    const dy = player.y - turretWorldY;
                    turret.angle = Math.atan2(dy, dx) - Math.PI / 2;
                    turret.shootTimer++;
                    if (turret.shootTimer > turret.shootInterval + Math.random() * 120) {
                        createEnemyBullet(turretWorldX, turretWorldY, player.x, player.y);
                        turret.shootTimer = 0;
                    }
                });
            }

            bullets.forEach(bullet => { bullet.y -= bullet.speed; });
            bullets = bullets.filter(bullet => bullet.y > -bullet.height);

            enemyBullets.forEach(bullet => { bullet.x += bullet.vx; bullet.y += bullet.vy; });
            enemyBullets = enemyBullets.filter(bullet => bullet.y < canvas.height + bullet.height && bullet.x > -bullet.width && bullet.x < canvas.width + bullet.width);

            enemies.forEach(enemy => {
                enemy.y += enemy.speed;
                enemy.shootTimer++;
                if (enemy.shootTimer > 300 && Math.random() < 0.005) {
                    createEnemyBullet(enemy.x + enemy.width/2, enemy.y + enemy.height, player.x, player.y);
                    enemy.shootTimer = 0;
                }
            });
            enemies = enemies.filter(enemy => enemy.y < canvas.height + enemy.height);

            clouds.forEach(c => { c.y += c.speed; });
            clouds = clouds.filter(c => c.y > canvas.height + c.height);
            islands.forEach(i => { i.y += i.speed; });
            islands = islands.filter(i => i.y > canvas.height + i.size);
            friendlyShips.forEach(s => { s.y += s.speed; });
            friendlyShips = friendlyShips.filter(s => s.y > canvas.height + s.height);
            mistParticles.forEach(p => { p.y += p.speed; });
            mistParticles = mistParticles.filter(p => p.y > canvas.height + p.radius);

            explosions.forEach(explosion => {
                explosion.life--;
                explosion.particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    particle.size *= 0.95;
                });
            });
            explosions = explosions.filter(explosion => explosion.life > 0);

            superBombExplosions.forEach(explosion => {
                explosion.life--;
                explosion.radius += (explosion.maxRadius - explosion.radius) * 0.08;
            });
            superBombExplosions = superBombExplosions.filter(explosion => explosion.life > 0);

            checkCollisions();

            createEnemy();
            if (Math.random() < 0.008) { createCloud(); }
            if (Math.random() < 0.002) { createIsland(); }
            if (Math.random() < 0.003) { createFriendlyShip(); }
            if (Math.random() < 0.05) { createMist(); }

            updateUI();
        }

        function checkCollisions() {
            if (gameState.isGameOver) return;
            bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width && bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
                        enemy.health -= bullet.damage;
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 1.2);
                            gameState.score += enemy.points;
                            enemies.splice(enemyIndex, 1);
                        }
                        bullets.splice(bulletIndex, 1);
                        return;
                    }
                });

                escortShips.forEach((ship, shipIndex) => {
                    if (bullet.x > ship.x - ship.width/2 && bullet.x < ship.x + ship.width/2 && bullet.y > ship.y - ship.height/2 && bullet.y < ship.y + ship.height/2) {
                        ship.health -= bullet.damage;
                        createExplosion(bullet.x, bullet.y, 0.6);
                        bullets.splice(bulletIndex, 1);
                        if (ship.health <= 0) {
                            createExplosion(ship.x, ship.y, 2.5);
                            gameState.score += 2500;
                            escortShips.splice(shipIndex, 1);
                        }
                        return;
                    }
                });

                if (gameState.bossPhase === 'yamato' && bullet.x > yamato.x - yamato.width/2 && bullet.x < yamato.x + yamato.width/2 && bullet.y > yamato.y - yamato.height/2 && bullet.y < yamato.y + yamato.height/2) {
                    yamato.health -= bullet.damage;
                    createExplosion(bullet.x, bullet.y, 0.8);
                    bullets.splice(bulletIndex, 1);
                    if (yamato.health <= 0) {
                        createExplosion(yamato.x, yamato.y, 5);
                        gameState.score += 20000;
                        gameState.bossPhase = 'victory';
                        gameState.isGameOver = true; // Stop player input
                        document.getElementById('bossHealth').style.display = 'none';
                        document.getElementById('victoryScreen').style.display = 'flex';
                        createConfettiBurst();
                        audioManager.play('victory');
                        audioManager.controlMusic(false);
                    }
                }
            });

            superBombExplosions.forEach(explosion => {
                 if (gameState.bossPhase === 'yamato') {
                    const dx = yamato.x - explosion.x;
                    const dy = yamato.y - explosion.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < explosion.radius && explosion.life > 60) {
                        yamato.health -= explosion.damage;
                        if (yamato.health <= 0) { /* ... */ }
                    }
                }
                escortShips.forEach((ship, shipIndex) => {
                    const dx = ship.x - explosion.x;
                    const dy = ship.y - explosion.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if(distance < explosion.radius && explosion.life > 60) {
                        ship.health -= explosion.damage;
                         if (ship.health <= 0) {
                            createExplosion(ship.x, ship.y, 2.5);
                            gameState.score += 2500;
                            escortShips.splice(shipIndex, 1);
                        }
                    }
                });
            });

            if (player.invulnerable <= 0) {
                const checkPlayerHit = (obj, objWidth, objHeight) => {
                    if (obj.x < player.x + player.width/2 && obj.x + objWidth > player.x - player.width/2 &&
                        obj.y < player.y + player.height/2 && obj.y + objHeight > player.y - player.height/2) {
                        
                        audioManager.play('playerHit');
                        createExplosion(player.x, player.y, 1.5);
                        gameState.lives--;
                        player.invulnerable = 150;
                        
                        if (gameState.lives <= 0) {
                            gameState.isGameOver = true;
                            document.getElementById('gameOver').style.display = 'block';
                        }
                        return true;
                    }
                    return false;
                }

                enemyBullets.forEach((bullet, bulletIndex) => {
                    if (checkPlayerHit(bullet, bullet.width, bullet.height)) {
                        enemyBullets.splice(bulletIndex, 1);
                        return;
                    }
                });

                enemies.forEach((enemy, enemyIndex) => {
                    if (checkPlayerHit(enemy, enemy.width, enemy.height)) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 1.2);
                        enemies.splice(enemyIndex, 1);
                        return;
                    }
                });
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = `ÂàÜÊï∏: ${gameState.score}`;
            let heartsText = '';
            for (let i = 0; i < gameState.lives; i++) { heartsText += '‚ù§Ô∏è'; }
            document.getElementById('lives').textContent = `ÁîüÂëΩ: ${heartsText}`;
            document.getElementById('energy').textContent = `ËÉΩÊ∫ê: ${Math.floor(gameState.energy)}%`;
            document.getElementById('energyFill').style.width = (gameState.energy / gameState.maxEnergy * 100) + '%';
            let bombsText = '';
            for (let i = 0; i < gameState.superBombs; i++) { bombsText += 'üí£'; }
            document.getElementById('superBombs').textContent = `Ë∂ÖÁ¥öÁÇ∏ÂΩà: ${bombsText}`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            clouds.forEach(cloud => {
                ctx.fillStyle = `rgba(255, 255, 255, ${cloud.opacity})`;
                ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
            });
            islands.forEach(drawIsland);
            friendlyShips.forEach(drawFriendlyShip);
            drawMist();

            if(gameState.bossPhase !== 'victory') {
                drawPlayer();
            }

            drawYamato();
            escortShips.forEach(drawEscortShip);
            enemies.forEach(enemy => { drawJapaneseZero(enemy); });

            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.shadowBlur = bullet.isSuper ? 20 : 12;
                ctx.shadowColor = bullet.color;
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                ctx.shadowBlur = 0;
            });
            enemyBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = bullet.color;
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                ctx.shadowBlur = 0;
            });
            explosions.forEach(explosion => {
                explosion.particles.forEach(particle => {
                    ctx.fillStyle = particle.color;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = particle.color;
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                    ctx.shadowBlur = 0;
                });
            });
            superBombExplosions.forEach(explosion => {
                const alpha = explosion.life / 80;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 10;
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#00FF00';
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 6;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#FFD700';
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius * 0.7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = '#FF4500';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#FF4500';
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius * 0.4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            });

            if (gameState.bossPhase === 'victory') {
                drawVictory();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            gameState = {
                score: 0, lives: 5, energy: 200, maxEnergy: 200, superBombs: 3,
                isGameOver: false, keys: gameState.keys, gameTime: 0, bossPhase: 'none', shootCooldown: 0
            };
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            player.invulnerable = 0;
            yamato.health = yamato.maxHealth;
            yamato.x = canvas.width / 2;
            bullets = []; enemyBullets = []; enemies = []; explosions = []; clouds = []; 
            superBombExplosions = []; escortShips = []; islands = []; friendlyShips = []; mistParticles = []; confetti = [];
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('bossHealth').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('credits').style.animation = 'none'; // Reset animation
            void document.getElementById('credits').offsetWidth; // Trigger reflow
            document.getElementById('credits').style.animation = null; 

            if (audioManager.isInitialized) {
                audioManager.controlMusic(true);
            }
        }

        async function initGameAudio() {
            await audioManager.init();
            document.removeEventListener('keydown', initGameAudioWrapper);
            document.removeEventListener('mousedown', initGameAudioWrapper);
        }
        
        const initGameAudioWrapper = () => initGameAudio();

        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            if ((e.key === 'b' || e.key === 'B') && !gameState.isGameOver) { createSuperBombExplosion(); }
            if (e.key === 'r' || e.key === 'R') { resetGame(); }
            if (e.key === ' ') { e.preventDefault(); }
        });

        document.addEventListener('keyup', (e) => { gameState.keys[e.key] = false; });
        canvas.addEventListener('mousemove', (e) => {
            if (!gameState.isGameOver) {
                const rect = canvas.getBoundingClientRect();
                player.x = e.clientX - rect.left;
                player.y = e.clientY - rect.top;
            }
        });
        canvas.addEventListener('mousedown', (e) => { if (!gameState.isGameOver && e.button === 0) { gameState.keys[' '] = true; } });
        canvas.addEventListener('mouseup', (e) => { if (e.button === 0) { gameState.keys[' '] = false; } });
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!gameState.isGameOver) { createSuperBombExplosion(); }
        });
        
        document.addEventListener('keydown', initGameAudioWrapper);
        document.addEventListener('mousedown', initGameAudioWrapper);

        gameLoop();
    </script>
</body>
</html>
